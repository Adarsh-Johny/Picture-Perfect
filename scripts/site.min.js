define(['angularAMD','app/Shared/Upload/documents-service','angular-ui-router'
], function (angularAMD) {
    return angular.module('eruditeApp.UserModule', [       
        'ui.router',
        //'eruditeApp.Patient.documentsService'
    ])
    .config(['$stateProvider', function ($stateProvider) {
        $stateProvider

             .state('app.user', angularAMD.route(
            {
                url: 'user',
                templateUrl: '/app/Crm/Templates/user-template.html',
                redirectTo: 'app.user.overview',
                controller: 'userTemplateController',
                controllerUrl: '/app/Crm/Templates/user-template-controller.js',
                privilegeId: 6
            }))

            .state('app.user.overview', angularAMD.route(
            {
                url: '/overview',
                templateUrl: '/app/Crm/Templates/overview.html',
                controller: 'userOverviewController',
                controllerUrl: '/app/Crm/Controllers/user-overview-controller.js',
                title: 'Overview'

            }))     
            .state('app.user.students', angularAMD.route(
               {
                   url: '/students',
                   templateUrl: '/app/Crm/Student/BasicInformation/student-grid.html',
                   controller: 'StudentGridController',
                   controllerUrl: '/app/Crm/Student/BasicInformation/student-grid-controller.js',
                   privilegeId: 29,
                   title: 'Students'
               }))
             .state('app.user.attendancerecord', angularAMD.route(
               {
                   url: '/attendance-record',
                   templateUrl: '/app/Crm/Student/Attendance/record-attendance.html',
                   controller: 'AttendanceRecordController',
                   controllerUrl: '/app/Crm/Student/Attendance/record-attendance-controller.js',
                   privilegeId: 29,
                   title: 'Students'
               }))
             .state('app.user.absentlist', angularAMD.route(
               {
                   url: '/absent-list',
                   templateUrl: '/app/Crm/Student/Attendance/absent-list.html',
                   controller: 'AbsentListController',
                   controllerUrl: '/app/Crm/Student/Attendance/absent-list-controller.js',
                   privilegeId: 29,
                   title: 'Students'
               }))

            .state('app.user.documents',angularAMD.route(
            {
                url: '/documents',
                templateUrl: '/app/Shared/Upload/patient-documents-grid-view.html',
                controller: 'documentsController',
                controllerUrl :'/app/Shared/Upload/documents-controller.js',
                privilegeId: 50,
                title: 'Documents'

            })).state('app.user.documents.add',  {
                url: '/add',
                privilegeId: 50,
                title: 'Documents',
                onEnter: ['$stateParams', '$state', '$$Documents',
                    function ($stateParams, $state, $$Documents) {
                        $$Documents.open()
                        .then(function (data) {
                            $state.go('^');
                            $state.loadGrid();
                        }).catch(function (err) {
                            $state.go('^', {}, { reload: true });
                        });
                    }]

            })
           .state('app.user.userSettings',angularAMD.route(
               {
                url: '/usersettings',
                templateUrl: '/app/Crm/UserSettings/userSettings.html',
                controller: 'userSettingsController',
                controllerUrl: '/app/Crm/UserSettings/userSttings-controller.js',
                privilegeId: 50,
                title: 'User Settings'
            }));

    }]);
});

angular.module('eruditeApp.SharedModule', [
  'eruditeApp.Shared.LayoutController',
  'eruditeApp.Shared.LoginController',
  'eruditeApp.Shared.LoginService',
  'eruditeApp.Shared.HeaderDirective',
  'eruditeApp.Shared.FooterDirective',
  'eruditeApp.Shared.LeftPaneDirective',
  'eruditeApp.Shared.InfoPaneDirective',
  'eruditeApp.Shared.DialogService',
  'eruditeApp.Shared.LookupService',
  'eruditeApp.Shared.ForgotPasswordModalService',
  'eruditeApp.Shared.setpasswordservice',
  'eruditeApp.Shared.AddressDirective',
  'eruditeApp.Shared.PhoneDirective',
  'eruditeApp.Shared.UiTrimDirective',
  'eruditeApp.Shared.TimePickerDirective',
  'eruditeApp.Shared.WeekPickerDirective',
  'eruditeApp.Shared.FormSubmitDirective',
  'eruditeApp.Shared.WeekPickerInputDirective',
  'eruditeApp.Shared.FormCancelDirective',
  'eruditeApp.Shared.GlobalSearchService',
  'eruditeApp.Shared.GlobalSearchController',
  'eruditeApp.Shared.Utilities',
  'IndeterminateCheckbox',
  'eruditeApp.Shared.Grid',
  'eruditeApp.Shared.Inbox',
  'eruditeApp.Shared.Dropdown',
  'eruditeApp.Shared.DateElement',
  'eruditeApp.Shared.File',
  'eruditeApp.Shared.Select',
  'eruditeApp.Shared.fzDateMultiSelect',
  'eruditeApp.Shared.signalREventRegister',
  'eruditeApp.Shared.SignalREventService',
  'eruditeApp.Shared.RecentPatientsService',
  'eruditeApp.Shared.RecentPatientsController',
  'eruditeApp.Shared.SignalREventService',
  'totime',
  'eruditeApp.Shared.AppointmentsGridDirective',
  'eruditeApp.Shared.AppointmentsGridService',
  'eruditeApp.Shared.ModelCloseDirective',
  'eruditeApp.Shared.Teeth'
]);


define(["app",
  'app/Shared/Directives/header-directive',
    'app/Shared/Services/login-service',
  'app/Shared/InfoPane/Directives/infoPane-directive',
  'app/Shared/Services/lookup-service',
  'app/Shared/fzDropdown/Directives/new-dropdown',
    'app/Shared/fzClose/Directives/fz-close',
    'app/Shared/fzSubmit/Directives/fz-submit',
    'app/Shared/fzCancel/Directives/fz-cancel',
    'toaster',
    'app/Shared/fzFile/Directives/fz-file'], function () {
        return angular.module('eruditeApp.User.OverviewController', [
          'eruditeApp.SharedModule',
          'toaster'
        ])
        .controller('userOverviewController', ['$scope','toaster','$$Lookup', '$$Login',
          function ($scope, toaster, $$Lookup, $$Login) {
              var date = new Date();

              $scope.uiState = {};
              $scope.uploadModel = {};           


              $scope.dates = [];
              $scope.dates2 = [];
              $scope.dates.push(date);

              $scope.dateOptions = {
                  dateFormat: "d MMM, yyyy",
              };
          }
        ]);
    });


define(['angular',
    'app/Shared/LeftPane/Directives/leftPane-directive',
    'app/Shared/ngIdle/angular-idle',
    'app/Shared/Directives/header-directive',
//'app/Scheduler/pscroll'
], function () {
        return angular.module('EruditeApp.User.UserTemplateController', [])
        .controller('userTemplateController', [function () {

        }]);
});


define(["angular",
    'ngDialog',
    'app/Shared/Services/lookup-service',
    'app/eruditeconfig'
  ], function () {
   return angular.module('eruditeApp.User.UserSettingsService', [])
  .service('$$UserSettings', ['$q', '$http', 'ERUDITE_CONFIG', function($q, $http, ERUDITE_CONFIG) {
    var apiUrl = ERUDITE_CONFIG.baseUrl;


    this.GetUserDetails = function() {
      return $http.get(apiUrl + 'user/user-settings/get');
    }
    this.UpdateUserDetails = function(userDetails) {

      return $http.post(apiUrl + 'user/user-settings/update', new UserDetails(userDetails));
    }
    this.GetProfiles = function() {
      return $http.get(apiUrl + 'lookups/get-profiles');
    }

    this.GetLoctions = function() {
      return $http.get(apiUrl + 'lookups/get-locations');
    }

    function UserDetails(e) {

      this.Prefix = e.Prefix || "";
      this.FirstName = e.FirstName || "";
      this.MiddleName = e.MiddleName || "";
      this.LastName = e.LastName || "";
      this.Suffix = e.Suffix || "";
      this.AddressDetail = new AddressDetail(e.AddressDetail) || "";
      this.DefaultProfileID= e.DefaultProfileID;
      this.DefaultLocationID= e.DefaultLocationID ||null;
      this.Phone = e.Phone || "";
      this.Mobile = e.Mobile || "";
      this.Email = e.Email || "";
    }

    function AddressDetail(e) {
      this.AddressLine1 = e.AddressLine1 || "";
      this.AddressLine2 = e.AddressLine2 || "";
      this.City = e.City || "";
      this.State = e.State || "";
      this.ZipCode = e.ZipCode || "";
    }

  }]);
});

/*global console,angular*/

define(['angular',
'app/User/UserSettings/userSettings-service',
'app/Shared/Services/DialogService',
'app/Shared/fzSubmit/Directives/fz-submit',
'app/Shared/fzCancel/Directives/fz-cancel',
'ngDialog'], function () {

  return angular.module('eruditeApp.User.UserSettingsController',[
  'eruditeApp.User.UserSettingsService',
  'ngEnter',
  'toaster',
  'ui.router'

]).controller('userSettingsController', ['$scope', '$$UserSettings', 'toaster', '$$DialogConfirm','$$Login','$state',
  function($scope, $$UserSettings, toaster, $$DialogConfirm,$$Login,$state) {

    //initialise

    $scope.isEditable = false;
    $scope.availableProfiles = [];
    $scope.loadUserDetails = function() {
      $$UserSettings.GetUserDetails()
        .success(function(resp) {

          $scope.userSettings = resp;
          $scope.loadUserPrfilesAndLocations();

          $scope.userSettingsMaster = angular.copy($scope.userSettings);

        })
        .error(function(error) {
          toaster.error("Something went wrong");
        });
    }
    $scope.loadUserPrfilesAndLocations = function() {

      $$UserSettings.GetProfiles()
        .success(function(resp) {

          $scope.availableProfiles = resp.filter(function(profile) {
            console.log(profile);
            var selectedprofiles = $scope.userSettings.UserProfile.filter(function(Id) {
              return profile.ProfileID == Id;
            });
            return selectedprofiles.length > 0;
          });
        })
        .error(function(err) {
          toaster.error("Error loading locations.");

        });

      $$UserSettings.GetLoctions()
        .success(function(resp) {

          if (resp.length > 0) {
            if ($scope.userSettings.UserLocation.indexOf(null) > -1) {
              resp.unshift({
                'LocationID': null,
                'LocationName': "All",
                'ShortName': 'All'
              });
              $scope.availableLocations = resp;
            } else {
                if(!$scope.userSettings.UserLocation.contains($scope.userSettings.DefaultLocationID)){ $scope.userSettings.DefaultLocationID = null};
              var locatons = resp.filter(function(location) {
                var selectedlocations = $scope.userSettings.UserLocation.filter(function(Id) {

                  return location.LocationID == Id;

                });
                return selectedlocations.length > 0;
              });
              if (locatons.length > 0) {
                locatons.unshift({
                  'LocationID': null,
                  'LocationName': "All",
                  'ShortName': 'All'
                });
              }
              $scope.availableLocations = locatons;
            }
          }
        }).error(function(err) {
          toaster.error("Error loading locations.");
        });
    }
    $scope.updateUserDetails = function() {
    	
		$$UserSettings.UpdateUserDetails($scope.userSettings)
	    .success(function(resp) {
	      $scope.toggleViewMode(false);
	      $scope.userSettingsMaster = angular.copy($scope.userSettings);
	      toaster.success("User Settings updated succesfully");
		  refreshRootScope();
	    })
	    .error(function(error) {
	      toaster.error("Something went wrong");
	    });

    };
	
	function refreshRootScope(){
		$$Login.GetUserContext();
	}
    $scope.toggleViewMode = function(value) {
      $scope.isEditable = value;
    }
    $scope.resetForm = function() {
      $scope.isEditable = false;
      $scope.userSettings = angular.copy($scope.userSettingsMaster);

    }
    $scope.loadUserDetails();

  }
]);
});

define(['angular',
    'app/eruditeconfig',
], function () {
    return angular.module('eruditeApp.Shared.AppointmentsGridService', [])
.service('$$AppointmentsService', ['$q', '$http', 'ERUDITE_CONFIG', '$filter', function ($q, $http, ERUDITE_CONFIG, $filter) {
    var baseUrl = ERUDITE_CONFIG.baseUrl;
    var self = this;
    self.GetAllAppts = function (gridRequest, patientid) {
        if (angular.isDefined(patientid)) {
            return $http.post(baseUrl + 'appointment/get-all-patient-appointment/' + patientid, gridRequest);
        } else {
            return $http.post(baseUrl + 'appointment/get-all', gridRequest);
        }
    };


    self.GetPastAppt = function (gridRequest, patientid) {
        if (angular.isDefined(patientid)) {
            return $http.post(baseUrl + 'appointment/get-past-patient-appointment/' + patientid, gridRequest);

        } else {
            return $http.post(baseUrl + 'appointment/get-past-appointments', gridRequest);
        }
    };

    self.GetUpcomingAppt = function (gridRequest, patientid) {
        if (angular.isDefined(patientid)) {
            return $http.post(baseUrl + 'appointment/get-upcoming-patient-appointment/' + patientid, gridRequest);

        } else {
            return $http.post(baseUrl + 'appointment/get-upcoming-appointments', gridRequest);
        }
    };
    self.PopulateAppointmentModel = function (model) {
        var AllAppointmentsModel = [];
        for (var i = 0; i < model.length; i++) {
            AllAppointmentsModel.push(AppointmentModel(model[i]));
        }
        return AllAppointmentsModel;
    }


self.GetRescheduledAppointments = function(gridRequest, patientid) {
        if (angular.isDefined(patientid)) {
            return $http.post(baseUrl + 'appointment/get-patient-reschedule-queue?patientID=' + patientid, gridRequest);
        } else {
            return $http.post(baseUrl + 'appointment/get-reschedule-queue',gridRequest)
        }
    };
self.GetMissedAppointments = function(gridRequest, patientid) {
        if (angular.isDefined(patientid)) {
            return $http.post(baseUrl + 'appointment/get-patient-missed-reschedule-queue?patientID=' + patientid, gridRequest);
        } else {
            return $http.post(baseUrl + 'appointment/get-missed-reschedule-queue',gridRequest)
        }
    };
self.GetPendingAppointments = function(gridRequest, patientid) {
        if (angular.isDefined(patientid)) {
            return $http.post(baseUrl + 'appointment/get-patient-pending-reschedule-queue?patientID=' + patientid, gridRequest);
        } else {
            return $http.post(baseUrl + 'appointment/get-pending-reschedule-queue',gridRequest)
        }
    };



    function AppointmentModel(model) {
        var newmodel = {};
        newmodel.AppointmentDate = model.AppointmentDate || "";
        newmodel.AppointmentID = model.AppointmentID || 0;
        newmodel.AppointmentType = model.AppointmentType || "";
        newmodel.AppointmentTime = model.AppointmentTime || '';
        newmodel.Location = model.Location || "";
        newmodel.Operatory = model.Operatory || "";
        newmodel.Patient = model.Patient || "";
        newmodel.Provider = model.Provider || "";
        newmodel.Status = model.Status || "";
        newmodel.RowVersionStamp = model.RowVersionStamp || "";
        return newmodel;
    }

}]);
});
/// <reference path="all-appointments-service.js" />
define(['angular',
    'app/Shared/AppointmentsGrid/all-appointments-service',
    'app/Scheduler/scheduler-service',
    'app/Shared/Services/login-service',
    'app/Shared/fzGrid/Directives/fz-grid',
    'app/Scheduler/Appointment/appointment-viewmodal-service',
    'app/Shared/Services/DialogService', 
  'app/Shared/fzUiTrim/fz-UiTrim',
    ], function () {
        return angular.module('eruditeApp.Shared.AppointmentsGridDirective', [])
        .directive('appointmentGridDirective', function () {
            var appointmentGridController = ['$rootScope', '$scope', '$$AppointmentsService', '$$Scheduler', '$$Login', 'toaster','$$AddAppointmentModal','$$DialogConfirm', function ($rootScope, $scope, $$AppointmentsService, $$Scheduler, $$Login, toaster,$$AddAppointmentModal,$$DialogConfirm) {
                
                $scope.showAllApptsGrid  = true;
                $scope.showMissedAppts = function(){
                    $scope.showAllApptsGrid  = false;
                };
                $scope.showAllAppts = function(){
                    $scope.showAllApptsGrid  = true;
                };

                const FILTER_ALL = 'ALL';
                const FILTER_PAST = 'PAST';
                const FILTER_UPCOMING = 'UPCOMING';
                const SOMETHING_WENT_WRONG = 'Something went wrong!, please try again';

                //Logic for all appointments grid -- Start

                $scope.allapptsmodel = {
                    title: 'Appointments : All',
                    PageIndex: 1,
                    PageSize: 15,
                    filters: {},
                    data: [],
                    colArray: ["AppointmentDate", "AppointmentTime", "Patient", "AppointmentType", "Provider", "Location", "Operatory", "Status"],
                    actionPermission: $$Login.CheckPrivileges(41, 'EDIT')
                };



                $scope.missedapptmodel = {
                    title: 'Missed/Pending Appointments',
                    PageIndex: 1,
                    PageSize: 15,
                    filters: {},
                    data: [],
                    colArray: ["Date", "AppointmentType", "PatientName", "StartTime", "Duration", "ProviderName", "LocationName", "Status"],
                    actionPermission : $$Login.CheckPrivileges(41, 'EDIT')
                };

                if (angular.isDefined($scope.patientid)) {
                    $scope.patientid = parseInt($scope.patientid);
                    $scope.allapptsmodel.colArray = ["AppointmentDate", "AppointmentTime", "AppointmentType", "Provider", "Location", "Operatory", "Status"];
                    $scope.missedapptmodel.colArray = ["Date", "AppointmentType", "StartTime", "Duration", "ProviderName", "LocationName", "Status"];

                }
                $rootScope.$on('AppointmentAdded', function () {
                    if($scope.showAllApptsGrid)
                        $scope.loadAllApptsGrid();
                    else
                        $scope.loadMissedApptsGrid();
                });


                $scope.appliedFilter = FILTER_ALL;
                $scope.loadAllApptsGrid = function () {
                    $scope.filterAllApptsGrid($scope.appliedFilter);
                };
                $scope.filterAllApptsGrid = function (filter) {
                    switch (filter) {
                        case FILTER_ALL:
                        loadAllAppts();
                        break;
                        case FILTER_PAST:
                        loadPastAppts();
                        break;
                        case FILTER_UPCOMING:
                        loadInUpcomingAppts();
                        break;
                    }

                };
                function loadAllAppts() {
                    $$AppointmentsService.GetAllAppts({
                        Filter: $scope.allapptsmodel.filters,
                        PageIndex: $scope.allapptsmodel.PageIndex,
                        PageSize: $scope.allapptsmodel.PageSize
                    }, $scope.patientid).success(function (resp) {
                        $scope.allapptsmodel.title = 'Appointments : All';
                        $scope.allapptsmodel.data = $$AppointmentsService.PopulateAppointmentModel(resp.Result);
                        $scope.allapptsmodel.gridTotalRecords = resp.TotalRecords;
                        $scope.appliedFilter = FILTER_ALL;
                        $scope.$broadcast('reformGrid');
                    }).error(function (error) {
                        toaster.error(SOMETHING_WENT_WRONG);
                        console.error(error);
                    });
                }


                function loadPastAppts() {
                    $$AppointmentsService.GetPastAppt({
                        Filter: $scope.allapptsmodel.filters,
                        PageIndex: $scope.allapptsmodel.PageIndex,
                        PageSize: $scope.allapptsmodel.PageSize
                    }, $scope.patientid).success(function (resp) {
                        $scope.allapptsmodel.title = 'Appointments : Past';
                        $scope.allapptsmodel.data = $$AppointmentsService.PopulateAppointmentModel(resp.Result);
                        $scope.allapptsmodel.gridTotalRecords = resp.TotalRecords;
                        $scope.appliedFilter = FILTER_PAST;
                        $scope.$broadcast('reformGrid');
                    }).error(function (error) {
                        toaster.error(SOMETHING_WENT_WRONG);
                        console.error(error);
                    });
                }


                function loadInUpcomingAppts() {
                    $$AppointmentsService.GetUpcomingAppt({
                        Filter: $scope.allapptsmodel.filters,
                        PageIndex: $scope.allapptsmodel.PageIndex,
                        PageSize: $scope.allapptsmodel.PageSize
                    }, $scope.patientid).success(function (resp) {
                        $scope.allapptsmodel.title = 'Appointments : Upcoming';
                        $scope.allapptsmodel.data = $$AppointmentsService.PopulateAppointmentModel(resp.Result);
                        $scope.allapptsmodel.gridTotalRecords = resp.TotalRecords;
                        $scope.appliedFilter = FILTER_UPCOMING;
                        $scope.$broadcast('reformGrid');
                    }).error(function (error) {
                        toaster.error(SOMETHING_WENT_WRONG);
                        console.error(error);
                    });
                }


                $scope.gridCommand = function (argument) {
                    var Appointments = [];
                    $scope.allapptsmodel.data.filter(function (d) {
                        if (d.selected) {
                            Appointments.push({ "value": d.AppointmentID, "RowVersionStamp": d.RowVersionStamp });
                        }
                    });
                    $$Scheduler.ChangeStatus(argument, Appointments)
                    .then(function () {
                        toaster.success("Appointment status changed successfully");
                        $scope.filterAllApptsGrid(FILTER_ALL);
                    })
                    .catch(function (err) {
                        toaster.error(SOMETHING_WENT_WRONG);
                        console.error(err);
                    })
                };

                //Logic for all appointments grid -- End

                //Logic for Missed/Pending Appointments -- Start
                const FILTER_MISSED_ALL = 'ALL';
                const FILTER_MISSED_MISSED = 'MISSED';
                const FILTER_MISSED_PENDING = 'PENDING';


                $scope.loadMissedApptsGrid = function(){

                    $scope.filterMissedApptsGrid(FILTER_MISSED_ALL);
                };

                function loadAllMissedAppts (){

                    $$AppointmentsService.GetRescheduledAppointments({
                        Filter: $scope.missedapptmodel.filters,
                        PageIndex: $scope.missedapptmodel.PageIndex,
                        PageSize: $scope.missedapptmodel.PageSize
                    }, $scope.patientid).success(function (resp) {
                        $scope.missedapptmodel.title = 'Missed/Pending Appointments : All';
                        $scope.missedapptmodel.data = resp.Result;
                        $scope.missedapptmodel.gridTotalRecords = resp.TotalRecords;
                        $scope.$broadcast('reformGrid');
                    }).error(function (error) {
                        toaster.error(SOMETHING_WENT_WRONG);
                        console.error(error);
                    });

                };


                function loadMissedAppts(){

                    $$AppointmentsService.GetMissedAppointments({
                        Filter: $scope.missedapptmodel.filters,
                        PageIndex: $scope.missedapptmodel.PageIndex,
                        PageSize: $scope.missedapptmodel.PageSize
                    }, $scope.patientid).success(function (resp) {
                        $scope.missedapptmodel.title = 'Missed/Pending Appointments : Missed';
                        $scope.missedapptmodel.data = resp.Result;
                        $scope.missedapptmodel.gridTotalRecords = resp.TotalRecords;
                        $scope.$broadcast('reformGrid');
                    }).error(function (error) {
                        toaster.error(SOMETHING_WENT_WRONG);
                        console.error(error);
                    });
                    
                };

                function loadPendingAppts (){

                    $$AppointmentsService.GetPendingAppointments({
                        Filter: $scope.missedapptmodel.filters,
                        PageIndex: $scope.missedapptmodel.PageIndex,
                        PageSize: $scope.missedapptmodel.PageSize
                    }, $scope.patientid).success(function (resp) {
                        $scope.missedapptmodel.title = 'Missed/Pending Appointments : Pending';
                        $scope.missedapptmodel.data = resp.Result;
                        $scope.missedapptmodel.gridTotalRecords = resp.TotalRecords;
                        $scope.$broadcast('reformGrid');
                    }).error(function (error) {
                        toaster.error(SOMETHING_WENT_WRONG);
                        console.error(error);
                    });
                    
                }



                showNewAppointment = function(selected){

                    if ($$Login.CheckPrivileges(41, "EDIT")) {
                    var data = {
                        "isRescheduled": true,
                        "PatientID": selected.PatientID,
                        "AppointmentID": selected.AppointmentID,
                        "ProviderID": selected.ProviderID,
                        "LocationID": selected.LocationID,
                        "Duration": selected.SlotLength,
                        "RowVersionStamp": selected.RowVersionStamp

                    };
                    $$AddAppointmentModal.open(data);
                    }
                }

                $scope.deleteRescheduledAppt = function(colname,row){

                $$DialogConfirm.open('Remove Appointment', 'This will remove the appointment from the reschedule queue. Do you want to proceed?')
                .then(function (value) {
                    if (value) {
                    var deletemodel = { "value": row.AppointmentID, "RowVersionStamp": row.RowVersionStamp };
                    $$Scheduler.DeleteAppointment(deletemodel)
                    .then(function (resp) {
                        toaster.success("Appointment deleted successfully.");
                        $scope.loadMissedApptsGrid();
                    }), function (err) {
                    toaster.error("Delete failed.");
                    console.error("delete failed", err);
                    };
                    }
                });


                }

                $scope.deletePermission = function(){
                    return $$Login.CheckPrivileges(41, "DELETE");
                };



                $scope.filterMissedApptsGrid = function(filter){
                    switch (filter) {
                        case FILTER_MISSED_ALL:
                        loadAllMissedAppts();
                        break;
                        case FILTER_MISSED_MISSED:
                        loadMissedAppts();
                        break;
                        case FILTER_MISSED_PENDING:
                        loadPendingAppts();
                        break;
                    }

                }
                //Logic for Missed/Pending Appointments -- End



            }];

            return {
                restrict: 'E',
                templateUrl: '/app/Shared/AppointmentsGrid/appointments-grid.html',
                controller: appointmentGridController,
                scope: {
                    patientid: '@'
                }

            }

        });
});
angular.module('eruditeApp.Shared.LayoutController', ['toaster'])
    .controller('layoutController', [
        '$scope',
        'toaster',
        function ($scope, toaster) {
            $scope.toastMessage = function(title, msg){
                toaster.success({title: title, body: msg});
            }
        }
    ]);

define([
    'app',
    'app/Shared/Services/login-service',
    'toaster',
    'app/Shared/Services/lookup-service',
    //'app/Shared/fzSubmit/Directives/fz-submit'
], function () {
        return angular.module('eruditeApp.Shared.LoginController', ['ui.router', 'toaster', 'ngCookies'])
        .controller('loginController', [
        '$scope', '$$Login', '$rootScope', '$state', 'toaster', '$cookies', '$$Lookup',
        function ($scope, $$Login, $rootScope, $state, toaster, $cookies, $$Lookup) {
            $scope.Login = {};
            $scope.loginErrorMessage = [];
            //Fetch all Accounts from database
            $$Lookup.GetAccounts()
              .success(function (resp) {
                  $scope.Login.Accounts = resp;
              });
            $cookies.put('userloggedin', '');
            $scope.Submit = function (isvalid) {
                if (isvalid) {
                    $scope.loginErrorMessage = [];
                    var loginRequest = {};
                    loginRequest.Email = $scope.Login.Email;
                    loginRequest.Password = $scope.Login.Password;
                    loginRequest.CollageID = $scope.Login.CollageID;
                    $$Login.Validate(loginRequest)
                      .then(function (resp) {
                          if (resp) {
                              $$Login.GetUserContext()
                                .then(function () {
                                    $state.go('app.user');
                                });
                          }
                      })
                      .catch(function (err) {
                          if (err && err.ModelState) {
                              var modelState = err.ModelState;
                              $scope.HandleServerErrors(modelState);
                              if ($scope.loginErrorMessage.length == 0) {
                                  if (modelState.LoginDisabled) {
                                      toaster.error("You do not have sufficient privilege to log in. Please consult your administrator");
                                  } else if (modelState.AccountLocked) {
                                      toaster.error("Account Locked. Please contact administrator");
                                  }
                              }
                          }
                      });
                }
            };
            $scope.HandleServerErrors = function (modelState) {
                $scope.loginErrorMessage = [];
                if (modelState.AccountLocked || modelState.LoginDisabled || modelState.IncorrectEmailPassword || modelState.NoLoginAccess) {
                    $scope.loginErrorMessage.push(modelState);
                }

            };
        }
        ]);
    });

angular.module('customHighlighter', [])
    .directive('customHighlighter', ['$timeout',function ($timeout) {
        return {
            restrict: 'A',
            require: '?ngModel',
            link: function (scope, elm, attrs, ctrl) {
                var highlight = false;
                attrs.$observe('customHighlighter', function (value) {
                    highlight = scope.$eval(value);

                       $timeout(function() {
                           if(highlight) {
                               $(elm).addClass('has-error');
                           }
                           else{
                               $(elm).removeClass('has-error');
                           }
                       }, 0);
                });
            }
        };
    }]);

angular.module('fzNumber', []).directive('fzNumber', function () {
    return {
        require: 'ngModel',
        restrict:'A',
        link: function (scope, element, attrs, modelCtrl) {
            modelCtrl.$parsers.push(function (inputValue) {
                // this next if is necessary for when using ng-required on your input. 
                // In such cases, when a letter is typed first, this parser will be called
                // again, and the 2nd time, the value will be undefined
                if (inputValue == undefined) return ''
                var transformedInput = inputValue.replace(/[^0-9]/g, '');
                if (transformedInput != inputValue) {
                    modelCtrl.$setViewValue(transformedInput);
                    modelCtrl.$render();
                }

                return transformedInput;
            });
        }
    };
});
angular.module('customValidation', [])
    .directive('customValidation', function () {
        return {
            restrict: 'A',
            require: '?ngModel',
            link: function (scope, elm, attrs, ctrl) {
                if(!ctrl)return;
                var expression = attrs.customValidation;
                ctrl.$validators.customValidation = function (modelValue, viewValue) {
                    if (evalExpr(scope,expression, viewValue)) {
                        console.log("here in true");
                        ctrl.$setViewValue(viewValue);
                        return true;
                    }
                    else {
                        console.log("here in false");
                        ctrl.$setViewValue(viewValue);
                        return false;
                    }
                };
            }
        };
        function evalExpr(scope, expr, vVal){
            if(expr.indexOf('(')){
                var fnName = expr.split('(')[0];
                var args = expr.split('(')[1].split(')')[0].split(',');
                args = args.map(function(it, i){
                    if(i==0){
                        return vVal;
                    }
                    if(it.indexOf('.')){
                        var tree = it.split('.');
                        var root = scope[tree[0]];
                        for(var i = 1; i<tree.length; i++){
                            root = root[tree[i]];
                        }
                        return root;
                    }else{
                        return scope[it];
                    }
                });
                var fn = scope[fnName];
                return fn.apply(null, args);
            }else{
                var fn = scope[expr];
                return fn();
            }
        }

    });

define(['angular'], function () {

    return angular.module('eruditeApp.Shared.FooterDirective', [])
    .directive('fuzeFooter', [function () {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: '/app/Shared/Templates/footer.html',
            controller: function () {

            }
        }
    }]);
});

define(['angular'], function () {
    return angular.module('fzZipMask', []).directive('fzZipMask', function () {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, element, attrs, ngModelController) {
                // Run formatting on keyup
                var formatZip = function (value) {
                    if (value == undefined) return '';
                    value = value.toString();
                    value = value.replace(/[^0-9]/g, '');
                    if (value.length > 9) {
                        value = value.slice(0, 9);
                    }
                    if (value.length > 5) {
                        value = value.slice(0, 5) + "-" + value.slice(5);
                    }

                    return value;
                };
                var applyFormatting = function () {
                    var value = element.val();
                    var original = value;
                    if (!value || value.length == 0) { return }
                    value = formatZip(value);
                    if (value != original) {
                        element.val(value);
                        element.triggerHandler('input')
                    }
                };
                element.bind('keyup', function (e) {
                    var keycode = e.keyCode;
                    var isTextInputKey =
                        (keycode > 47 && keycode < 58) || // number keys
                        keycode == 32 || keycode == 8 || // spacebar or backspace
                        (keycode > 64 && keycode < 91) || // letter keys
                        (keycode > 95 && keycode < 112) || // numpad keys
                        (keycode > 185 && keycode < 193) || // ;=,-./` (in order)
                        (keycode > 218 && keycode < 223);   // [\]' (in order)
                    if (isTextInputKey) {
                        applyFormatting();
                    }
                });

                ngModelController.$formatters.push(function (value) {
                    if (!value || value.length == 0) {
                        return value;
                    }
                    value = formatZip(value);
                    return value;
                });
            }
        };
    });
});

/// <reference path="../fzDropdown/Directives/fz-dropdown.js" />
define(["angular",
     'ngDialog',
     'app/Shared/fzDropdown/Directives/fz-dropdown',
     'app/Shared/Services/signalREventRegister',
     'app/Shared/Services/signalREventService',
     'app/Shared/fzUiTrim/fz-UiTrim',
     'app/Shared/ngIdle/fz-idle',
     'app/Shared/ngIdle/ngIdle-localStorage'

], function () {

    return angular.module('eruditeApp.Shared.HeaderDirective',
        [           
            'ngIdle.localStorage'
        ])
  //.directive('fuzeHeader', ['$$PatientAddModal', '$$AddAppointmentModal', '$$Alert', '$$Documents', '$$PrescriptionModalService', '$$AddNoteModalService', function ($$PatientAddModal, $$AddAppointmentModal, $$Alert, $$Documents, $$PrescriptionModalService, $$AddNoteModalService) {
  //    var headerController = ['$scope', '$rootScope', '$state', '$$PrescriptionContext', '$$SignalREventRegister', '$$SignalREventService', 'toaster', function ($scope, $rootScope, $state, $$PrescriptionContext, $$SignalREventRegister, $$SignalREventService, toaster) {

  .directive('fuzeHeader', [
      function () {
          var headerController = ['$scope', '$rootScope', '$state', 'toaster', '$$SignalREventRegister', '$$SignalREventService', '$$DialogConfirm', '$$Login', 'IdleLocalStorage',
          function ($scope, $rootScope, $state, toaster, $$SignalREventRegister, $$SignalREventService, $$DialogConfirm, $$Login, $$PaymentModalService, IdleLocalStorage) {






              $scope.showUserMenu = false;
              $scope.toggleUserMenu = function () {
                  $scope.showUserMenu = !$scope.showUserMenu;
                  $scope.userMenuStyle = {
                      'display': $scope.showUserMenu ? 'block' : 'none'
                  };
              };

              //signal r
              var updateAlertCount = function (alert) {
                  if (alert.Type == "Profiles") {
                      $rootScope.AlertCount = alert.Count;
                      if (alert.Alert != null) {
                          var alertModel = [];
                          alertModel.push(alert.Alert);
                          $$Alert.openAlert(alertModel, "Profile");
                      }
                  }
                  else if (alert.Type == "Patients") {
                      if (alert.Alert != null) {
                          var alertModel = [];
                          alertModel.push(alert.Alert);
                          $$Alert.openAlert(alertModel, "Patients");
                      }
                  }
                  console.log('alert', alert);
              };




              $rootScope.$on('ProfileSwitched', updateprofilealertcountAndDialog);
              $scope.$on('$destroy', function iVeBeenDismissed() {
                  // say goodbye to your controller here
                  // release resources, cancel request...
                  $$SignalREventRegister.UnRegister('updateAlertCount');
                  $$SignalREventRegister.UnRegister('updatedUserDetails');
              });
              //signalr sample end
          }];
          return {
              restrict: 'E',
              replace: true,
              controller: headerController,
              templateUrl: '/app/Shared/Templates/header.html'
          };
      }]);
//.directive('fuzeDropdown', ['$document', function ($document) {
//    return {
//        restrict: 'E',
//        scope: {},
//        transclude: true,
//        replace: true,
//        templateUrl: '/app/Shared/Templates/profileDropDown.html',
//        controller: ['$rootScope', '$scope', '$element', '$$Login', 'toaster', '$state', function ($rootScope, $scope, $element, $$Login, toaster, $state) {
//            $scope.toggleUserMenu = function () {
//                $scope.showUserMenu = !$scope.showUserMenu;
//                $scope.userMenuStyle = {
//                    'display': $scope.showUserMenu ? 'block' : 'none'
//                };
//            };
//            if (typeof $rootScope.User != "undefined") {
//                $scope.AvailableProfiles = $rootScope.User.userProfile;
//                $scope.CurrentProfileID = $rootScope.User.ActiveProfileID;
//            }
//            $scope.SwitchProfile = function (profileID, profileName) {
//                $$Login.SwitchProfile(profileID)
//                  .success(function (resp) {
//                      $rootScope.User.ActiveProfileID = profileID;
//                      $rootScope.User.ActiveProfileName = profileName;
//                      $rootScope.User.ActiveUserProfile = resp;
//                      $rootScope.$broadcast('ProfileSwitched');
//                      $scope.CurrentProfileID = profileID;
//                      $scope.showUserMenu = !$scope.showUserMenu;
//                      $state.go('app.user.overview');
//                  })
//                  .error(function (err) {
//                      toaster.error("Profile switching failed.Please try again");
//                  });
//            };
//            $scope.Logout = function () {
//                $$Login.Logout()
//                  .then(function () {
//                      toaster.success("You have been successfully logged out");
//                  });
//                $state.go('login');
//            };
//        }],
//        link: function (scope, element, attr, ctrl) {
//            element.find('li > a').bind('click', function () {
//                scope.$apply(function () {
//                    scope.showUserMenu = false;
//                    scope.userMenuStyle = {
//                        'display': 'none'
//                    };
//                });
//            });
//            $document.bind('click', function (event) {
//                var isClickedElementChildOfPopup = element
//                  .find(event.target)
//                  .length > 0;

//                if (isClickedElementChildOfPopup) {
//                    return;
//                }

//                scope.$apply(function () {
//                    scope.showUserMenu = false;
//                    scope.userMenuStyle = {
//                        'display': 'none'
//                    };
//                });
//            });
//        }
//    };
//}]);
});

/*global define,angular*/
define(['angular'], function () {
    return angular.module('IndeterminateCheckbox', [])
    .directive('indeterminate', [function () {
        return {
            require: '?ngModel',
            link: function (scope, el, attrs, ctrl) {
                var truthy = true;
                var falsy = false;
                var nully = null;
                ctrl.$formatters = [];
                ctrl.$parsers = [];
                ctrl.$render = function () {
                    var d = ctrl.$viewValue;
                    el.data('checked', d);
                    switch (d) {

                        case truthy:
                            el.prop('indeterminate', false);
                            el.prop('checked', true);
                            break;
                        case falsy:
                            el.prop('indeterminate', false);
                            el.prop('checked', false);
                            break;
                        case nully:
                            el.prop('indeterminate', true);
                            break;
                        default:
                            el.prop('indeterminate', true);
                    }
                };
                el.bind('click', function () {
                    var d;
                    switch (el.data('checked')) {
                        case falsy:
                            d = truthy;
                            break;
                        case truthy:
                            d = falsy;
                            break;
                        default:
                            d = falsy;
                    }
                    ctrl.$setViewValue(d);
                    scope.$apply(ctrl.$render);
                });
            }
        };
    }]);
});

define(['angular'], function() {
  return angular.module('loadingIndicator', [])
    .directive('loadingIndicator', ['$timeout', function($timeout) {
      return {
        restrict: 'E',
        replace: true,
        scope: true,
        template: "<div  data-ng-class='isLoading?\"active\":\"\"' class='loading-indicator'> Loading...</div>",
        link: function(scope, elm, attrs) {
          scope.$watch(scope.isLoading, function(v) {});
        }
      };
    }]);
});

angular.module('ngEnter',[])
.directive('ngEnter',[function(){
  return function(scope,element,attrs){
    element.bind("keydown keypress",function(event){
      if(event.which === 13){
        scope.$apply(function(){
          scope.$eval(attrs.ngEnter);
        });
        event.preventDefault();
      }
    });
  };
}])
    .directive("updateModelOnEnter", function() {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function (scope, elem, attrs, ngModelCtrl) {
      elem.bind("keyup",function(e) {
        if (e.keyCode === 13) {
          scope.$apply(function() {
            ngModelCtrl.$commitViewValue();
          });
        }
      });
    }
  }
});

angular.module('eruditeApp.Shared.SidebarDirective', [])
.directive('eruditeSidebar', [function () {
    return {
        restrict: 'E',
        templateUrl: '/app/Shared/Templates/sidebar.html'
    }
}]);

angular.module('eruditeApp.Shared.tableDirective', [])
.directive('fuzeTable', [function () {
    return {
        restrict: 'E',
        scope :{gridData :'='},
        controller: ['$scope', function($scope){
          $scope.Heading = "Table Name";
          $scope.gridRequest = {
            Filter: {},
            PageIndex: 1,
            PageSize: 5
          };
          $scope.gridTotalRecords = 0;
          $scope.gridData = [];

          $scope.recalculatePaging = function() {
            if ($scope.gridRequest.PageIndex == 1) {
              $scope.gridPrevDisabled = true;
              $scope.gridFromRecord = $scope.gridRequest.PageIndex;
              if ($scope.gridRequest.PageSize > $scope.gridTotalRecords) {
                $scope.gridNextDisabled = true;
                $scope.gridToRecord = $scope.gridTotalRecords;
              } else {
                $scope.gridNextDisabled = false;
                $scope.gridToRecord = $scope.gridRequest.PageSize;
              }
            } else {
              $scope.gridPrevDisabled = false;
              $scope.gridFromRecord = $scope.gridToRecord + 1;
              if ($scope.gridRequest.PageSize * $scope.gridRequest.PageIndex > $scope.gridTotalRecords) {
                $scope.gridNextDisabled = true;
                $scope.gridToRecord = $scope.gridTotalRecords
              } else {
                $scope.gridNextDisabled = false;
                $scope.gridToRecord = $scope.gridRequest.PageSize * $scope.gridRequest.PageIndex;
              }
            }
          }

          $scope.nextPage = function() {
            if (!$scope.gridNextDisabled) {
              $scope.gridRequest.PageIndex++;
              $scope.loadGrid();
            }
          }

          $scope.prevPage = function() {
            if (!$scope.gridPrevDisabled) {
              $scope.gridRequest.PageIndex--;
              $scope.loadGrid();
            }
          }


          $scope.recalculatePaging();
          $scope.loadGrid();
        }],
        templateUrl: '/app/Shared/Templates/table.html'
    }
}]);


define(['angular'], function () {
    return angular.module('uiSelectRequired', [])
            .directive('uiSelectRequired', function () {
                return {
                    restrict: 'A',
                    require: '?ngModel',
                    link: function (scope, elm, attrs, ctrl) {
                        var required = "false";

                        attrs.$observe('uiSelectRequired', function (value) {
                            required = value;
                            ctrl.$validate();
                        });

                        ctrl.$validators.uiSelectRequired = function (modelValue, viewValue) {
                            var determineVal;
                            if (required == "true") {
                                if (!angular.isUndefined(attrs.multiple)) {
                                    if (angular.isArray(modelValue)) {
                                        determineVal = modelValue;
                                    } else if (angular.isArray(viewValue)) {
                                        determineVal = viewValue;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else {
                                    return !ctrl.$isEmpty(modelValue);
                                }
                                return determineVal.length > 0;
                            }
                            else {
                                return true;
                            }

                        };
                    }
                };
            });
});
angular.module('validateOnBlur',[])
    .directive("validateOnBlur", [function() {
        return {
            restrict: "A",
            require: "ngModel",
            scope: {},
            link: function(scope, element, attrs, modelCtrl) {
                element.on('blur', function () {
                    modelCtrl.$showValidationMessage = modelCtrl.$dirty;
                    element.addClass("has-visited");
                    scope.$apply();
                });
            }
        };
    }]);

angular.module('eruditeApp.Shared.DialogService', ['ngDialog'])
  .service('$$DialogConfirm', ['ngDialog', '$q', function(ngDialog, $q) {

    this.open = function(main, content) {
      var deferred = $q.defer();
      var template = function() {
        var temp = '';

        if ((!!main) && (main.constructor === String)) {
          temp = '<div class="fz-dialog-header"><h2>' + main + '</h2></div>';
          temp += '<div class="fz-dialog-content-inner"><div class="fz-form-content border">' + content + '</div></div>';
          temp += '<div class="fz-form-alert-footer"><ul class="fz-action flex-row align-end">';
          temp += '<li><button type="button" class="fz-button fz-button-blue" ng-click="confirm(true)">Yes</button></li>';
          temp += '<li><button type="button" class="fz-button fz-button-blue" ng-click="confirm(false)">No</button></li>';
          temp += '</ul></div>';
        } else if ((!!main) && (main.constructor === Array)) {
          temp = '<div class="fz-dialog-header"><h2>' + main[0] + '</h2></div>';
          temp += '<div class="fz-dialog-content-inner"><div class="fz-form-content border">' + main[1] + '</div></div>';
          temp += '<div class="fz-form-alert-footer"><ul class="fz-action flex-row align-end">';
          temp += '<li><button type="button" class="fz-button fz-button-blue" ng-click="confirm(true)">Yes</button></li>';
          temp += '<li><button type="button" class="fz-button fz-button-blue" ng-click="confirm(false)">No</button></li>';
          temp += '</ul></div>';
        } else if ((!!main) && (main.constructor === Object)) {
          temp = '<div class="fz-dialog-header"><h2>' + main.title + '</h2></div>';
          temp += '<div class="fz-dialog-content-inner"><div class="fz-form-content border">' + main.content + '</div></div>';
          temp += '<div class="fz-form-alert-footer"><ul class="fz-action flex-row align-end">';
          main.action.forEach(function(a) {
              temp += '<li><button type="button" class="fz-button fz-button-blue" ng-click="confirm(' + a.value + ')">' + a.label + '</button></li>'
          });
          temp += '</ul></div>';
        }


        return temp;
      }

      ngDialog.openConfirm({
        template: template(),
        plain: true,
        className: "small"
      }).then(function(value) {
        deferred.resolve(value);
      });
      return deferred.promise;
    }

  }]);

define(["angular",
    'toaster',
    'ngDialog',
    'app/Shared/Services/login-service',
    'xtForm',
    //'app/Shared/fzSubmit/Directives/fz-submit',
], function () {
    'use strict';
    return angular.module('eruditeApp.Shared.ForgotPasswordModalService', ['ngDialog'])
      .service('$$ForgotPasswordModalService', ['$q', 'ngDialog', function ($q, ngDialog) {

          this.open = function () {
              var deferred = $q.defer();
              ngDialog.openConfirm({
                  template: '/app/Shared/Templates/forgotpassword.html',
                  className: "medium",
                  showClose: false,
                  controller: ForgotPasswordController,
                  //scope: scope
              }).then(function (value) {
                  deferred.resolve(value);
              }).catch(function () {
                  deferred.resolve(false);
              });
              return deferred.promise;
          }

          var ForgotPasswordController = ['$scope', '$$Login', 'toaster', '$$Lookup', function ($scope, $$Login, toaster, $$Lookup) {
              $scope.invalidEmailMessage = [];
              //Fetch all Accounts from database
              $$Lookup.GetAccounts()
                .success(function (resp) {
                    if (typeof $scope.ForgotPassword == "undefined")
                        $scope.ForgotPassword = {};
                    $scope.ForgotPassword.Accounts = resp;
                })
              $scope.forgotpassword = function (isvalid) {
                  if (isvalid) {
                      if (typeof $scope.ForgotPassword !== "undefined")
                          $scope.invalidEmailMessage = [];
                      $$Login.ForgotPassword($scope.ForgotPassword)
                        .success(function (resp) {
                            toaster.success("A link to initiate password reset has been sent to your mail. Please check your email for further directions to log in to the system.");
                            $scope.closeThisDialog();
                        })
                        .error(function (err) {
                            $scope.invalidEmailMessage = [];
                            if (err.ModelState.UnregisteredEmail) {
                                $scope.invalidEmailMessage.push(err.ModelState);
                            }
                            else if (typeof err.ModelState.InsufficientPrivilege !== "undefined") {
                                $scope.invalidEmailMessage.push(err.ModelState);
                            }
                            else {
                                toaster.error("Something went wrong. Please try again");
                            }
                        })
                  }

              }
          }]
      }]);
});
(function() {

    'use strict';

    var module = angular.module('eruditeApp.Shared.LoginModalService', []);

    module.factory('$$LoginModalService', ['$document', '$compile', '$controller', '$http', '$rootScope', '$q', '$templateCache',
        function($document, $compile, $controller, $http, $rootScope, $q, $templateCache) {

            //  Get the body of the document, we'll add the modal to this.
            var body = $document.find('body');

            function LoginModalService() {

                var self = this;

                //  Returns a promise which gets the template, either
                //  from the template parameter or via a request to the
                //  template url parameter.
                var getTemplate = function(template, templateUrl) {
                    var deferred = $q.defer();
                    if(template) {
                        deferred.resolve(template);
                    } else if(templateUrl) {
                        // check to see if the template has already been loaded
                        var cachedTemplate = $templateCache.get(templateUrl);
                        if(cachedTemplate !== undefined) {
                            deferred.resolve(cachedTemplate);
                        }
                        // if not, let's grab the template for the first time
                        else {
                            $http({method: 'GET', url: templateUrl, cache: true})
                                .then(function(result) {
                                    // save template into the cache and return the template
                                    $templateCache.put(templateUrl, result.data);
                                    deferred.resolve(result.data);
                                }, function(error) {
                                    deferred.reject(error);
                                });
                        }
                    } else {
                        deferred.reject("No template or templateUrl has been specified.");
                    }
                    return deferred.promise;
                };

                self.showModal = function(options) {

                    //  Create a deferred we'll resolve when the modal is ready.
                    var deferred = $q.defer();

                    //  Validate the input parameters.
                    var controllerName = options.controller;
                    if(!controllerName) {
                        deferred.reject("No controller has been specified.");
                        return deferred.promise;
                    }

                    //  If a 'controllerAs' option has been provided, we change the controller
                    //  name to use 'as' syntax. $controller will automatically handle this.
                    if(options.controllerAs) {
                        controllerName = controllerName + " as " + options.controllerAs;
                    }

                    //  Get the actual html of the template.
                    getTemplate(options.template, options.templateUrl)
                        .then(function(template) {

                            //  Create a new scope for the modal.
                            var modalScope = $rootScope.$new();

                            //  Create the inputs object to the controller - this will include
                            //  the scope, as well as all inputs provided.
                            //  We will also create a deferred that is resolved with a provided
                            //  close function. The controller can then call 'close(result)'.
                            //  The controller can also provide a delay for closing - this is
                            //  helpful if there are closing animations which must finish first.
                            var closeDeferred = $q.defer();
                            var inputs = {
                                $scope: modalScope,
                                close: function(result, delay) {
                                    if(delay === undefined || delay === null) delay = 0;
                                    window.setTimeout(function() {
                                        //  Resolve the 'close' promise.
                                        closeDeferred.resolve(result);

                                        //  We can now clean up the scope and remove the element from the DOM.
                                        modalScope.$destroy();
                                        modalElement.remove();

                                        //  Unless we null out all of these objects we seem to suffer
                                        //  from memory leaks, if anyone can explain why then I'd
                                        //  be very interested to know.
                                        inputs.close = null;
                                        deferred = null;
                                        closeDeferred = null;
                                        modal = null;
                                        inputs = null;
                                        modalElement = null;
                                        modalScope = null;
                                    }, delay);
                                }
                            };

                            //  If we have provided any inputs, pass them to the controller.
                            if(options.inputs) {
                                for(var inputName in options.inputs) {
                                    inputs[inputName] = options.inputs[inputName];
                                }
                            }

                            //  Parse the modal HTML into a DOM element (in template form).
                            var modalElementTemplate = angular.element(template);

                            //  Compile then link the template element, building the actual element.
                            //  Set the $element on the inputs so that it can be injected if required.
                            var linkFn = $compile(modalElementTemplate);
                            var modalElement = linkFn(modalScope);
                            inputs.$element = modalElement;

                            //  Create the controller, explicitly specifying the scope to use.
                            var modalController = $controller(controllerName, inputs);

                            //  Finally, append the modal to the dom.
                            if (options.appendElement) {
                                // append to custom append element
                                options.appendElement.append(modalElement);
                            } else {
                                // append to body when no custom append element is specified
                                body.append(modalElement);
                            }

                            //  We now have a modal object...
                            var modal = {
                                controller: modalController,
                                scope: modalScope,
                                element: modalElement,
                                close: closeDeferred.promise
                            };

                            //  ...which is passed to the caller via the promise.
                            deferred.resolve(modal);

                        })
                        .then(null, function(error) { // 'catch' doesn't work in IE8.
                            deferred.reject(error);
                        });

                    return deferred.promise;
                };

            }

            return new LoginModalService();
        }]);

}());

define(["angular", 
		'app/eruditeconfig',
		'angular-cookies',		
     	'app/Shared/ngIdle/ngIdle-localStorage'], function () {
    return angular.module('eruditeApp.Shared.LoginService', ['ngCookies','ngIdle.localStorage'])
    .service('$$Login', ['$http', 'ERUDITE_CONFIG', '$rootScope', "$q", "$cookies","IdleLocalStorage",
    function ($http, ERUDITE_CONFIG, $rootScope, $q, $cookies,IdleLocalStorage) {
        var baseurl = ERUDITE_CONFIG.baseUrl;
        this.Logout = function () {
            var deferred = $q.defer();
            $http.post(baseurl + 'login/logout', {})
              .then(function () {
                  deferred.resolve();
              })
              .catch(function (err) {
                  console.error("something went wrong while logging out from the web api", err);
                  deferred.reject(err);
              });
            $cookies.put('userloggedin', '');
            IdleLocalStorage.remove('alertOnLoadShowed');
            return deferred.promise;
        };
        this.Validate = function (Login) {
            var deferred = $q.defer();
            $http.post(baseurl + 'login', Login)
              .success(function (resp) {
                  $cookies.put('userloggedin', 'true');
                  deferred.resolve(resp);
              })
              .error(function (err) {
                  $cookies.put('userloggedin', '');
                  deferred.reject(err);
              });

            return deferred.promise;
        };
        this.GetUserContext = function () {

            var deferred = $q.defer();
            $http.post(baseurl + 'setup/user/get-user-login-context')
              .success(function (resp) {
                  $rootScope.User = {};
                  $rootScope.User = resp;
                  if (typeof $rootScope.User != "undefined") {
                      $rootScope.User.ActiveProfileName = $rootScope.User.userProfile.filter(function (profile) {
                          return profile.ProfileID == $rootScope.User.ActiveProfileID;
                      })[0].ProfileName;
                  }
                  deferred.resolve(true);
              })
              .error(function (err) {
                  console.error(err);
                  deferred.reject(false);
              });
            return deferred.promise;
        };
        this.SwitchProfile = function (profileID) {
            return $http.post(baseurl + 'user/switch-profile/' + profileID);
        };

        this.CheckPrivileges = function (privilegeIDs, privilege) {
            if (typeof privilege == "undefined") {
                privilege = 'VIEW';
            }
            privilegeArray = privilege.replace(/^\s+|\s+$/g, "").split(/\s*,\s*/);
            if (typeof $rootScope.User != "undefined") {
                var childProfiles = [];

                if (!angular.isUndefined(privilegeIDs) && privilegeIDs.constructor === Number) {
                    childProfiles = $rootScope.User.ActiveUserProfile.filter(function (child) {
                        return child.ParentID == privilegeIDs;
                    });
                } else if (!angular.isUndefined(privilegeIDs) && privilegeIDs.constructor === Array) {
                    $.each(privilegeIDs, function (i, v) {
                        var tempchildren = $rootScope.User.ActiveUserProfile.filter(function (child) {
                            return child.ParentID == v;
                        });
                        $.merge(childProfiles, tempchildren);
                    });
                }
                if (childProfiles.length > 0) {

                    for (var i = 0; i < childProfiles.length; i++) {
                        var activeProfile = childProfiles[i];

                        if (!angular.isUndefined(privilegeIDs) && privilegeIDs.constructor === Array) {

                            for (var j = 0; j < privilegeArray.length; j++) {
                                if (activeProfile.AllowedPrivileges.indexOf(privilegeArray[j]) > -1) {
                                    return true;
                                }
                            }
                        } else if (!angular.isUndefined(privilegeIDs) && privilegeIDs.constructor === Number) {
                            for (var j = 0; j < privilegeArray.length; j++) {
                                if (activeProfile.AllowedPrivileges.indexOf(privilegeArray[j]) > -1) {
                                    return true;
                                }
                            }
                        }
                    }

                } else {
                    for (var i = 0; i < $rootScope.User.ActiveUserProfile.length; i++) {
                        var activeProfile = $rootScope.User.ActiveUserProfile[i];
                        if (!angular.isUndefined(privilegeIDs) && privilegeIDs.constructor === Array) {

                            for (var j = 0; j < privilegeArray.length; j++) {
                                if (privilegeIDs.indexOf(activeProfile.PrivilegeID) > -1 && activeProfile.AllowedPrivileges.indexOf(privilegeArray[j]) > -1) {
                                    return true;
                                }
                            }
                        } else if (!angular.isUndefined(privilegeIDs) && privilegeIDs.constructor === Number) {
                            for (var j = 0; j < privilegeArray.length; j++) {
                                if (activeProfile.PrivilegeID == privilegeIDs && activeProfile.AllowedPrivileges.indexOf(privilegeArray[j]) > -1) {
                                    return true;
                                }
                            }
                        }
                    }

                }
            }
            return false;
        };

        this.ForgotPassword = function (model) {
            return $http.post(baseurl + 'Login/forgot-password', model);
        };

        this.keepAlive = function () {
            return $http.post(baseurl + 'Login/session-keep-alive', {});
        }
    }
    ]);
});
/*global define,angular*/

define(["angular",
    'ngDialog', 'app/eruditeconfig'
], function () {
    return angular.module('eruditeApp.Shared.LookupService', [])
       .service('$$Lookup', ['$http', 'ERUDITE_CONFIG', '$q', function ($http, ERUDITE_CONFIG, $q) {
           var apiUrl = ERUDITE_CONFIG.baseUrl;

           this.getProfiles = function () {
               return $http.get(apiUrl + 'lookups/get-profiles');
           };

           this.getAllCourses = function () {
               var deferred = $q.defer();
               var promise = deferred.promise;
               $http.get(apiUrl + 'lookups/get-courses')
               .then(function (resp) {
                   var resp = resp.data;
                   deferred.resolve(resp);
               })
               .catch(function (error) {
                   deferred.reject(error);
               });
               promise.success = function (callback) {
                   promise.then(callback);
                   return promise;
               };
               promise.error = function (callback) {
                   promise.catch(callback);
                   return promise;
               };

               return promise;
           };
           this.getAllBatches = function () {
               var deferred = $q.defer();
               var promise = deferred.promise;
               $http.get(apiUrl + 'lookups/get-batches')
               .then(function (resp) {
                   var resp = resp.data;
                   deferred.resolve(resp);
               })
               .catch(function (error) {
                   deferred.reject(error);
               });
               promise.success = function (callback) {
                   promise.then(callback);
                   return promise;
               };
               promise.error = function (callback) {
                   promise.catch(callback);
                   return promise;
               };

               return promise;
           };
           this.getAllDivisions = function () {
               var deferred = $q.defer();
               var promise = deferred.promise;
               $http.get(apiUrl + 'lookups/get-divisions')
               .then(function (resp) {
                   var resp = resp.data;
                   deferred.resolve(resp);
               })
               .catch(function (error) {
                   deferred.reject(error);
               });
               promise.success = function (callback) {
                   promise.then(callback);
                   return promise;
               };
               promise.error = function (callback) {
                   promise.catch(callback);
                   return promise;
               };

               return promise;
           };

           this.getAssignedUsers = function () {
               return $http.get(apiUrl + 'lookups/get-users');
           };

           this.GetAccounts = function () {
               return $http.get(apiUrl + 'utility/get-account-list');
           };

       }]);
});

/*global angular,define*/
define(["angular",
    'toaster',
    'ngDialog',
    'xtForm',
    'app/Shared/fzSubmit/Directives/fz-submit',
    'app/eruditeconfig'
], function () {
    'use strict';
    var setpasswordController = ['$scope', '$timeout', '$$setpasswordservice', 'toaster', '$state', '$stateParams',
       function ($scope, $timeout, $$setpasswordservice, toaster, $state, $stateParams) {
           $scope.request = {};
           $scope.PasswordMismatchMsg = [];
           $scope.validUrl = false;
           $$setpasswordservice.validateurl($stateParams.token)
             .success(function (resp) {
                 if (resp === false) {
                     $scope.validUrl = true;
                 } else {
                     $scope.validUrl = false;
                     toaster.error("Link Expired");
                     $state.go('login');
                 }
             })
             .error(function (err) {
                 if (!(angular.isUndefined(err.ModelState.ResetpasswordLink))) {
                     toaster.error(err.ModelState.ResetpasswordLink.toString());
                 } else if (!(angular.isUndefined(err.ModelState.LinkExpired))) {
                     toaster.error(err.ModelState.LinkExpired.toString());
                 } else {
                     toaster.error("Something went wrong. Please try again");
                 }
                 $state.go('login');
             });
           $scope.Submit = function () {
               $timeout(function () {
                   $scope.PasswordMismatchMsg = [];
               });
               var msg = '', pattern = /(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{5,32}/, doSubmit = true;
               if (!$scope.request.Password) {
                   msg = "The password you entered doesn't meet the above criteria";
                   doSubmit = false;
               }
               else if (!pattern.test($scope.request.Password)) {
                   msg = "The password you entered doesn't meet the above criteria";
                   doSubmit = false;
               }
               else if ($scope.request.Password !== $scope.request.passwordconfirm) {
                   msg = "Password doesn't match";
                   doSubmit = false;
               }
               if (msg && !doSubmit) {
                   $scope.PasswordMismatchMsg = [{ "WrongPassword": msg }];
                   return false;
               }
               $scope.request.Token = $stateParams.token;
               $$setpasswordservice.savepassword($scope.request)
                 .success(function (resp) {
                     toaster.success("Password Changed successfully");
                     $state.go('login');
                 })
                 .error(function (err) {
                     if (!(angular.isUndefined(err.ModelState.WeakPassword))) {
                         toaster.error(err.ModelState.WeakPassword.toString());
                     } else if (!(angular.isUndefined(err.ModelState.LinkExpired))) {
                         toaster.error(err.ModelState.LinkExpired.toString());
                         $state.go('login');
                     } else if (!(angular.isUndefined(err.ModelState.Password))) {
                         toaster.error(err.ModelState.Password.toString());
                     }
                     else {
                         toaster.error("Something went wrong. Please try again");
                         $state.go('login');
                     }
                 });
           };
       }
    ];



    return angular.module('eruditeApp.Shared.setpasswordservice', [])
        .controller('setpasswordController', setpasswordController)
        .service('$$setpasswordservice', ['$http', 'ERUDITE_CONFIG', '$q',
            function ($http, ERUDITE_CONFIG, $q) {
                var baseurl = ERUDITE_CONFIG.baseUrl;

                this.validateurl = function (token) {
                    return $http.post(baseurl + 'Login/is-password-link-expired/' + token);
                };

                this.savepassword = function (request) {
                    return $http.post(baseurl + 'Login/set-password/', request);
                };
            }
        ]);
});
define(['angular'], function () {

    return angular.module('eruditeApp.Shared.signalREventRegister', [])
        .service('$$SignalREventRegister', [function () {
            this.EventHandlers = this.EventHandlers || [];
            this.Register = function (eventname, handler) {
                this.EventHandlers.push({ eventName: eventname, event: handler });
            }
            this.UnRegister = function (eventname) {
                this.EventHandlers = this.EventHandlers.filter(function (el) {
                    return el.eventName != eventname;
                });
            }
            this.handleEvent = function (eventname, handler) {
                angular.forEach(this.EventHandlers, function (item) {
                    if (item.eventName === eventname) {
                        item.event(handler);
                    }
                });
            }
        }]);
});

define(['angular', 
    'app/Shared/Services/signalREventRegister', 
    'angular-signalr-hub',
    'app/eruditeconfig'], function () {

    angular.module('eruditeApp.Shared.SignalREventService', [])
        .factory('$$SignalREventService', ["$http", "$rootScope", "$location", "Hub", "$timeout", '$$SignalREventRegister', 'ERUDITE_CONFIG',
        function ($http, $rootScope, $location, Hub, $timeout, $$SignalREventRegister, ERUDITE_CONFIG) {
            var Events = this;
            //Hub setup
            var hub = new Hub("eventHub", {
                listeners: {
                    'handleEvent': function (eventname, handler) {
                        $$SignalREventRegister.handleEvent(eventname, handler);
                        $rootScope.$apply();
                    }
                },
                //methods: ['send'],//server methods
                errorHandler: function (error) {
                    console.error(error);
                },
                hubDisconnected: function () {
                    if (hub.connection.lastError) {
                        hub.connection.start();
                    }
                },
                transport: 'webSockets',
                logging: false,
                rootPath: ERUDITE_CONFIG.baseUrl + 'signalr'
            });
            return Events;
        }]);
});
define(['angular'], function () {

    return angular.module('eruditeApp.Shared.UtilityService', [])
        .service('$$Utility', [function () {
            this.getUUID = function () {
                var d = new Date().getTime();
                var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    var r = (d + Math.random() * 16) % 16 | 0;
                    d = Math.floor(d / 16);
                    return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                });
                return uuid;
            };
        }]);
});


define(["angular",
    'app/eruditeconfig',
    'ngDialog',
    'app/Shared/fzClose/Directives/fz-close',
    'app/Shared/fzSubmit/Directives/fz-submit',
    'app/Shared/fzCancel/Directives/fz-cancel',
    'app/Shared/fzFile/Directives/fz-file.js'
], function () {

    return angular.module('eruditeApp.Patient.documentsService', [])
  .service('$$Documents', ['$http', 'ERUDITE_CONFIG', 'ngDialog', '$q',

    function ($http, ERUDITE_CONFIG, ngDialog, $q) {
        var apiUrl = ERUDITE_CONFIG.baseUrl;

        this.UploadGrid = function (gridRequest) {

            var deferred = $q.defer(),
                   promise = deferred.promise;
            $http.post(apiUrl + 'upload/get-all-uploads', gridRequest)
            .then(function (resp) {
                deferred.resolve(resp.data);
            })
            .catch(function (error) {
                deferred.reject(error.data);
            });
            promise.success = function (callback) {
                promise.then(callback);
                return promise;
            };
            promise.error = function (callback) {
                promise.catch(callback);
                return promise;
            };
            return promise;
        }
        this.DocumentGriddirective = function (gridRequest, patientID) {

            return $http.post(apiUrl + 'documents/get-all-documents-by-patient/' + patientID, gridRequest);
        }

        this.ViewUploadErrors = function (uploadID) {
            var deferred = $q.defer();
            window.open(apiUrl + 'upload/get-upload-error-report/' + uploadID, '_blank');
            deferred.resolve();
            return deferred.promise;
        }

        this.Delete = function (documentIds) {
            return $http.post(apiUrl + 'documents/Delete', documentIds);
        }
        this.AddDocument = function (addDocument) {
            return $http.post(apiUrl + 'upload/add', addDocument, {
                transformRequest: angular.identity,
                headers: {
                    'Content-Type': undefined
                }
            });
        }

        this.open = function (id) {
            var deferred = $q.defer();
            ngDialog.openConfirm({
                template: 'app/Shared/Upload/add-document-modal.html',
                className: "large",
                resolve: {
                    id: function () {
                        return id;
                    }
                },
                controller: documentModalController
            }).then(function (value) {
                deferred.resolve(value);
            }).catch(function () {
                deferred.resolve(false);
            });
            return deferred.promise;
        };

        var documentModalController = ['$scope', '$$Documents', 'toaster', '$$Lookup', '$element', '$filter', 'id', '$rootScope',
          function ($scope, $$Documents, toaster, $$Lookup, $element, $filter, id, Upload, $rootScope) {

              $scope.addDocument = {};
              $scope.availablePatients = [];
              $scope.ServerErrorMessages = [];
              $scope.uiState = {};
              $scope.uiState.showDocumentsTab = false
              $scope.uiState.selectPatientTab = true;
              $scope.isPatientContext = false;
              $scope.getAllPatients = function () {
                  $$Lookup.getPatients()
                    .success(function (resp) {
                        $scope.availablePatients = angular.copy(resp);
                    })
                    .error(function (error) {
                        ShowDocumentErrorMessages(error);
                    });
              }
              $scope.addDocuments = function () {
                  $scope.uiState.showDocumentsTab = true
                  $scope.uiState.selectPatientTab = false;
              }
              $scope.showPatient = function () {
                  $scope.uiState.showDocumentsTab = false
                  $scope.uiState.selectPatientTab = true;
              }
              //Submit a new document
              $scope.submitDocument = function (type) {
                  var newDocument = new FormData();
                  newDocument.append('UploadedFile', $scope.addDocument.File);
                  newDocument.append('DocumentType', $scope.addDocument.DocumentType);
                  newDocument.append('Description', $scope.addDocument.Description);
                  newDocument.append('PatientID', $scope.addDocument.patientID);
                  $$Documents.AddDocument(newDocument).then(function (resp) {

                      if (type == 'Save') {
                          $scope.closeThisDialog();
                      }
                      $scope.addDocument = {};
                      if (id) {
                          $scope.addDocument.patientID = id;
                      }
                      toaster.success("Document added Successfully");
                  }, function (error) {
                      ShowDocumentErrorMessages(error.data);
                  });
              }


              function ShowDocumentErrorMessages(error) {
                  if (error.ModelState) {
                      $scope.ServerErrorMessages = [];
                      $scope.ServerErrorMessages.push(error.ModelState);
                  } else {
                      toaster.error('Something went wrong!');
                  }
              }
              if (!id) {
                  $scope.getAllPatients();
              } else {
                  $scope.uiState.showDocumentsTab = true
                 // $scope.uiState.selectPatientTab = true;
                  $scope.addDocument.patientID = id;
                  $scope.isPatientContext = true;
              }


          }
        ];

    }
  ]);
});

/*global angular,define*/

define(['angular',
    'app/Shared/Upload/documents-service',
    'app/Shared/fzClose/Directives/fz-close',
    'app/Shared/Services/lookup-service',
    'app/Shared/fzSubmit/Directives/fz-submit',
    'app/Shared/fzCancel/Directives/fz-cancel',
    'toaster',
    'app/Shared/fzGrid/Directives/fz-grid',
    'app/Shared/fzFile/Directives/fz-file'
], function () {
    return angular.module("eruditeApp.Patient.Documents.DocumentUploadDirective", ['toaster'])
   .directive("fzDocumentAttach", ['$compile', function ($compile) {
       return {
           restrict: "E",
           scope: {
               uploadType: '=',
           },
           replace: true,
           templateUrl: '/app/Shared/Upload/fz-document-attach.html',
           controller: ['$scope', '$element', '$$Documents', 'toaster', '$rootScope', '$document','$$Lookup',
           function ($scope, $element, $$Documents, toaster, $rootScope, $document,$$Lookup) {
               $scope.NewUpload = false;
               $scope.uiState = {};
               $scope.uploadModel = {};
               $scope.uiState.Divisions=[{DivisionID:null,DivisionName:'Select'}];
               $scope.uiState.Batches=[{BatchID:null,BatchStartYear:'Select'}];
               $scope.uiState.Courses=[{CourseID:null,CourseName:'Select'}];
               //Get All Divisions
               function getAllDivisions() {
                   $$Lookup.getAllDivisions()
                   .success(function (resp) {
                     //$scope.uiState.Divisions={DivisionID:null,DivisionName:'Select'}
                       $scope.uiState.Divisions.push.apply($scope.uiState.Divisions,resp);
                   })
                   .error(function () {
                       console.log("Could't get all divisions")
                   })
               }
               //Get all Batches
               function getAllBatches() {
                   $$Lookup.getAllBatches()
                   .success(function (resp) {
                       $scope.uiState.Batches.push.apply($scope.uiState.Batches,resp);
                   })
                   .error(function () {
                       console.log("Could't get all Batches")
                   })
               }
               //Get all Courses
               function getAllCourses() {
                   $$Lookup.getAllCourses()
                   .success(function (resp) {
                       $scope.uiState.Courses.push.apply($scope.uiState.Courses,resp);
                   })
                   .error(function () {
                       console.log("Could't get all Courses")
                   })
               }
               getAllDivisions();
               getAllBatches();
               getAllCourses();


               $scope.model = {
                   title: 'Uploads',
                   PageIndex: 1,
                   PageSize: 15,
                   filters: {},
                   data: [],
                   //infiniteScroll: true

               };
               $scope.onLoad = function () {
                   $$Documents.UploadGrid({
                       Filter: $scope.model.filters,
                       PageIndex: $scope.model.PageIndex,
                       PageSize: $scope.model.PageSize
                   })
                     .success(function (resp) {
                         $scope.model.data = resp.Result;
                         $scope.model.gridTotalRecords = resp.TotalRecords;
                         $scope.$broadcast('reformGrid');
                     })
                     .error(function (error) {

                         toaster.error("Something went wrong while loading the grid");
                     });
               };
               $scope.$on('filterChanged', function () {
                   $scope.model.data = [];
                   $scope.model.PageIndex = 1;
               });

               $scope.submitDocument = function (type) {
                   $scope.uploadModel.UploadType = $scope.uploadType;
                   var newDocument = new FormData();
                   newDocument.append('UploadedFile', $scope.uploadModel.File);
                   newDocument.append('UploadType', $scope.uploadModel.UploadType);
                   newDocument.append('Note', $scope.uploadModel.Note);
                   if ($scope.uploadModel.UploadType === "BATCH COURSE STUDENT" || $scope.uploadModel.UploadType === "BATCH COURSE TIMETABLE") {
                       var contxt = {
                           CollageID: 10001,
                           BatchID: $scope.uploadModel.BatchID,
                           CourseID: $scope.uploadModel.CourseID
                       };
                       newDocument.append('Context', JSON.stringify(contxt));
                   }
                   $$Documents.AddDocument(newDocument).success(function (resp) {
                       $rootScope.$broadcast('xtreset');
                       $scope.uploadModel = {};
                       $scope.NewUpload = true;
                       toaster.success("Document added Successfully");
                   }, function (error) {

                       showDocumentErrorMessages(error.data);
                   });
               };

               function showDocumentErrorMessages(error) {
                   if (error.ModelState) {
                       $scope.ServerErrorMessages = [];
                       $scope.ServerErrorMessages.push(error.ModelState);
                   } else {
                       toaster.error('Something went wrong!');
                   }
               }

               $scope.ViewUploadErrors = function (row) {
                   if (row.UploadStatus == 'COMPLETED WITH ERROR') {
                       $$Documents.ViewUploadErrors(row.UploadID);
                   }                 
               };

           }],
           link: function (scope, element, attributes) {
           }
       };
   }]);
});

// var validation = angular.module('eruditeApp.Shared.Validation');
//
// validation.directive("telephone", function () {
//         return {
//             restrict: "A",
//             require: "?ngModel",
//             link: function (scope, element, attributes, ngModel) {
//                 ngModel.$validators.telephone = function (modelValue) {
//                     if (modelValue == "ACME") {
//                         return true;
//                     }
//                     else return false;
//                 };
//             }
//         };
//     });
//
//     app.directive("firstname", function () {
//         return {
//             restrict: "A",
//             require: "?ngModel",
//             link: function (scope, element, attributes, ngModel) {
//                 ngModel.$validators.firstname = function (modelValue) {
//                     if (modelValue == "Tony" || modelValue == "John") {
//                         return true;
//                     }
//                     else return false;
//                 };
//             }
//         };
//     });
//
//
//     app.directive("userexists", function ($q, $timeout) {
//
//         var CheckUserExists = function (name) {
//             if (name == "Tony") {
//                 return true;
//             }
//             else if (name == "John") {
//                 return false;
//             }
//             else {
//                 return false;
//             }
//         };
//
//         return {
//             restrict: "A",
//             require: "ngModel",
//             link: function (scope, element, attributes, ngModel) {
//                 ngModel.$asyncValidators.userexists = function (modelValue) {
//                     var defer = $q.defer();
//                     $timeout(function () {
//                         if (CheckUserExists(modelValue)) {
//                             defer.resolve();
//                         } else {
//                             defer.reject();
//                         }
//                     }, 2000);
//                     return defer.promise;
//                 }
//             }
//         };
//     });

angular.module('currencyMask', []).directive('currencyMask', function () {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function (scope, element, attrs, ngModelController) {
            // Run formatting on keyup
            var numberWithCommas = function (value, addExtraZero) {
                if (addExtraZero == undefined)
                    addExtraZero = false
                value = value.toString();
                value = value.replace(/[^0-9\.]/g, "");
                var parts = value.split('.');
                parts[0] = parts[0].replace(/\d{1,3}(?=(\d{3})+(?!\d))/g, "$&,");
                if (parts[1] && parts[1].length > 2) {
                    parts[1] = parts[1].substring(0, 2);
                }
                if (addExtraZero && parts[1] && (parts[1].length === 1)) {
                    parts[1] = parts[1] + "0"
                }
                return parts.join(".");
            };
            var applyFormatting = function () {
                var value = element.val();
                var original = value;
                if (!value || value.length == 0) { return }
                value = numberWithCommas(value);
                if (value != original) {
                    element.val(value);
                    element.triggerHandler('input')
                }
            };
            element.bind('keyup', function (e) {
                var keycode = e.keyCode;
                var isTextInputKey =
                    (keycode > 47 && keycode < 58) || // number keys
                    keycode == 32 || keycode == 8 || // spacebar or backspace
                    (keycode > 64 && keycode < 91) || // letter keys
                    (keycode > 95 && keycode < 112) || // numpad keys
                    (keycode > 185 && keycode < 193) || // ;=,-./` (in order)
                    (keycode > 218 && keycode < 223);   // [\]' (in order)
                if (isTextInputKey) {
                    applyFormatting();
                }
            });
            element.bind('blur', function (evt) {
                if (angular.isDefined(ngModelController.$modelValue)) {
                    var val = ngModelController.$modelValue.split('.');
                    if (val && val.length == 1) {
                        if (val != "") {
                            ngModelController.$setViewValue(val + '.00');
                            ngModelController.$render();
                        }
                    } else if (val && val.length == 2) {
                        if (val[1] && val[1].length == 1) {
                            ngModelController.$setViewValue(val[0] + '.' + val[1] + '0');
                            ngModelController.$render();
                        }
                        else if (val[1].length == 0) {
                            ngModelController.$setViewValue(val[0] + '.00');
                            ngModelController.$render();
                        }
                    }
                }
            })
            ngModelController.$parsers.push(function (value) {
                if (!value || value.length == 0) {
                    return value;
                }
                value = value.toString();
                value = value.replace(/[^0-9\.]/g, "");
                return value;
            });
            ngModelController.$formatters.push(function (value) {
                if (!value || value.length == 0) {
                    return value;
                }
                value = numberWithCommas(value, true);
                return value;
            });
        }
    };
});
define(['angular','app/Shared/Services/login-service'], function () {
    return angular.module('eruditeApp.Shared.UiTrimDirective', [])
        .directive("fzUiTrim", ['$state', '$rootScope', '$$Login', function ($state, $rootScope, $$Login) {
            return {
                restrict: "A",
                scope: {},
                link: function (scope, element, attrs, modelCtrl) {
                    var privilege = 'VIEW';
                    var privilageIdAttrs = attrs.privilegeId || '';
                    var privilageIdAttrs = privilageIdAttrs.split(',').map(function (n) {
                        return parseInt(n);
                    });
                    var privilegeId = isNaN(privilageIdAttrs[0]) ? $state.current.privilegeId : privilageIdAttrs;
                    attrs.$observe('fzUiTrim', function (value) {
                        if (value) {
                            privilege = value.toUpperCase();
                            if (!$$Login.CheckPrivileges(privilegeId, privilege)) {
                                element.hide();
                            }
                        }
                    });

                    $rootScope.$on('ProfileSwitched', function () {
                        privilege = angular.isDefined(attrs.fzUiTrim) ? attrs.fzUiTrim.toUpperCase() : "VIEW";
                        if (!$$Login.CheckPrivileges(privilegeId, privilege)) {
                            element.hide();
                        } else {
                            element.show();

                        }
                    });

                }
            };
        }]);
});
define(["angular", 
    'app/Shared/fzWeekPicker/fzWeekPicker', 
    'scripts/ngDropover/dist/ngdropover.min'], function() {
    return angular.module('eruditeApp.Shared.WeekPickerInputDirective', [])
        .directive('fzWeekPickerInput', [function() {
            var weekPickerInputController = ['$scope', '$rootScope', '$document', function($scope, $rootScope, $document) {

                $scope.dropoverOptions = {
                    position: 'bottom',
                    triggerEvent: 'click',
                    closeOnClickOff: true,
                };

                $scope.dateOptions = {
                    dateFormat: "d M, yy",
                    changeMonth: true,
                    changeYear: true
                };
            }];
            return {
                restrict: 'E',
                replace: true,
                templateUrl: '/app/Shared/fzWeekPicker/Templates/fz-week-picker.html',
                //scope: {
                //    startDate: '=',
                //    endDate: '='
                //},

                controller: weekPickerInputController,

                link: function(scope, element, attrs, ctrl) {
                    var date = scope.$eval(attrs.startDate);
                    scope.date = date || new Date();
                    scope.startDate = scope.date;
                    scope.$watch('date', function() {
                        var todayDate = scope.date,
                            startDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), (todayDate.getDate() - todayDate.getDay()) + 1),
                            endDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate() - todayDate.getDay() + 7);

                        scope.startDate = startDate;
                        scope.endDate = endDate;

                        scope.filterBar.startDate = startDate; //TODO: Need to remove this, must add as scope element
                        scope.filterBar.endDate = endDate; //TODO: Need to remove this, must add as scope element

                        scope.$emit('ngDropover.close', 'week-picker');
                    });

                    scope.$watch('filterBar.startDate', function() {
                        scope.startDate = scope.filterBar.startDate;
                        scope.endDate = scope.filterBar.endDate;
                    });
                }
            };
        }]);
});

define(["angular", ], function() {
    return angular.module('eruditeApp.Shared.WeekPickerDirective', [])
        .directive('fzWeekPicker', ['$timeout', 'uiDateConverter', '$parse', function($timeout, uiDateConverter, $parse) {
            return {
                restrict: 'A',
                require: '?ngModel',
                link: function(scope, element, attrs, ngModel) {
                    if (!ngModel) return;
                    var getOptions = function() {
                        return angular.extend({
                            showOtherMonths: true,
                            selectOtherMonths: true,
                            changeMonth: true,
                            changeYear: true,
                            dateFormat: 'd M, yy',
                            firstDay: 1,
                            defaultDate: scope.$eval(attrs.startDate)
                        }, scope.$eval(attrs.fzWeekPicker));
                    };
                    var initDateWidget = function() {
                        var optionsObj = getOptions();
                        var selectCurrentWeek = function() {
                            scope.$apply(function() {
                                $("#ui-datepicker-div").find(".ui-datepicker-current-day a").addClass("ui-state-active");
                            });
                        };

                        var updateModel = function(date, dateFormat, dateTxt) {
                            scope.$apply(function() {
                                ngModel.$setViewValue(element.datepicker('getDate'));
                            });
                            var modelAccessor = $parse(attrs.ngModel);
                            scope.$apply(function(scope) {
                                modelAccessor.assign(scope, date);
                            });
                        };

                        optionsObj.onSelect = function(dateTxt, picker) {
                            var date = $(element).datepicker('getDate');
                            $timeout(function() {
                                selectCurrentWeek();
                            }, true);
                            updateModel(date, optionsObj.dateFormat, dateTxt);
                        };

                        optionsObj.beforeShow = function(dateTxt, inst) {
                            $timeout(function() {
                                selectCurrentWeek();
                            }, true);
                        }

                        optionsObj.beforeShowDay = function(date) {
                            var cssClass = '';
                            var todayDate = $(element).datepicker('getDate');
                            if (todayDate) {
                                var startDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), (todayDate.getDate() - todayDate.getDay()) + 1);
                                var endDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate() - todayDate.getDay() + 7);
                                if (date >= startDate && date <= endDate)
                                    cssClass = 'week-active';
                                return [true, cssClass];
                            }
                        };

                        optionsObj.onChangeMonthYear = function(year, month, inst) {
                            $timeout(function() {
                                selectCurrentWeek();
                            }, true);
                        };

                        ngModel.$render = function() {
                            //var date = ngModel.$modelValue;
                            var date = scope.$eval(attrs.startDate);
                            if (angular.isUndefined(date) || date === null || !angular.isDate(date)) {
                                if (angular.isString(ngModel.$viewValue)) {
                                    date = uiDateConverter.stringToDate(attrs.uiDateFormat, ngModel.$viewValue);
                                } else {
                                    throw new Error('ng-Model value must be a Date, or a String object with a date formatter - currently it is a ' + typeof date + ' - use ui-date-format to convert it from a string');
                                }
                            }
                            element.datepicker('setDate', date);
                        };

                        if (element.data('datepicker')) {
                            // Updates the datepicker options
                            element.datepicker('option', optionsObj);
                            element.datepicker('refresh');
                        } else {
                            // Creates the new datepicker widget
                            element.datepicker(optionsObj);

                            //Cleanup on destroy, prevent memory leaking
                            element.on('$destroy', function() {
                                element.datepicker('destroy');
                            });
                        }

                        ngModel.$render();
                    }
                    scope.$watch(getOptions, initDateWidget, true);
                }
            };
        }])
        .factory('uiDateConverter', ['uiDateFormatConfig', function(uiDateFormatConfig) {

            function dateToString(dateFormat, value) {
                dateFormat = dateFormat || uiDateFormatConfig;
                if (value) {
                    if (dateFormat) {
                        return jQuery.datepicker.formatDate(dateFormat, value);
                    }

                    if (value.toISOString) {
                        return value.toISOString();
                    }
                }
                return null;
            }

            function stringToDate(dateFormat, value) {
                dateFormat = dateFormat || uiDateFormatConfig;
                if (angular.isString(value)) {
                    if (dateFormat) {
                        return jQuery.datepicker.parseDate(dateFormat, value);
                    }

                    var isoDate = new Date(value);
                    return isNaN(isoDate.getTime()) ? null : isoDate;
                }
                return null;
            }

            return {
                stringToDate: stringToDate,
                dateToString: dateToString
            };

        }])
        .constant('uiDateFormatConfig', '');
});

/*** Directives and services for responding to idle users in AngularJS
* @author Mike Grabski <me@mikegrabski.com>
* @version v1.1.1
* @link https://github.com/HackedByChinese/ng-idle.git
* @license MIT
*/
define(["angular",
    'app/Shared/ngIdle/ngIdle-keepAlive',
    'app/Shared/ngIdle/ngIdle-idle',
    'app/Shared/ngIdle/ngIdle-localStorage',
], function () {
    'use strict';
    return angular.module('ngIdle', ['ngIdle.keepalive', 'ngIdle.idle', 'ngIdle.localStorage']);


});
define(['angular', 'app/Shared/ngIdle/angular-idle', 'ngDialog'], function () {
    return angular.module('fzIdle', ['ngIdle'])
.controller('fzIdleCtrl', ['$scope', 'Idle', 'ngDialog', '$interval', '$$Login', '$state', 'toaster', 'IdleLocalStorage', function ($scope, Idle, ngDialog, $interval, $$Login, $state, toaster, IdleLocalStorage) {
    $scope.started = false;
    
    var idleTimeOut = 300;
    var idleTime = 1800;
    $scope.counter;
    $scope.popup = null;

    function closeModals() {
        if ($scope.popup) {
            $scope.popup.close();
            $scope.popup = null;
        }
    }

    function resetTimer() {
        $scope.displayTimer = '05:00';
        $scope.timer = 299;

        if (angular.isDefined($scope.counter)) {
            $interval.cancel($scope.counter);
            $scope.counter = undefined;
        }
    }

    $scope.$on('IdleStart', function () {
        IdleLocalStorage.set('status', { status:'start'});
        StartCountDown();

        $scope.popup = ngDialog.open({
            template: 'app/Shared/ngIdle/Template/fzIdleTemplate.html',
            className: "medium",
            controller: 'fzIdleCtrl',
            scope: $scope
        });

    });

    $scope.$on('IdleEnd', function () {
    });

    $scope.$on('fzIdle-keepAlive', function () {
        closeModals();
        resetTimer();
    });
   
    $scope.$on('fzIdle-logout', function () {
        $scope.stop();
        closeModals();
        resetTimer();
        logout();
    });
    $scope.$on('IdleTimeout', function () {
        $scope.stop();
        closeModals();
        resetTimer();
        logout();
    });

    $scope.start = function () {
        Idle.setIdle(idleTime);
        Idle.setTimeout(idleTimeOut);
        Idle.watch();
        $scope.started = true;
    };

    $scope.stop = function () {
        Idle.unwatch();
        $scope.started = false;

    };

    $scope.confirm = function (value) {
        closeModals();
        resetTimer();
        if (value == true) {
            // continue the session, update the server that the client is alive.
            keepAlive();
            IdleLocalStorage.set('status', { status: 'keepAlive' });
        }
        else {
            // logout from the current session.
            IdleLocalStorage.set('status', { status: 'logout' });
            logout();
        }
    }

    $scope.$on('$destroy', function () {
        // Make sure that the interval is destroyed too
        if (angular.isDefined($scope.counter)) {
            $interval.cancel($scope.counter);
            $scope.counter = undefined;
        }
    });

    function StartCountDown() {

        resetTimer();

        $scope.counter = $interval(function () {
            $scope.displayTimer = rectime($scope.timer);
            $scope.timer--;

            if ($scope.timer == -1 ) {
                $interval.cancel($scope.counter);
            }

        }, 1000);
    }

    function rectime(sec) {
        var hr = Math.floor(sec / 3600);
        var min = Math.floor((sec - (hr * 3600)) / 60);
        sec -= ((hr * 3600) + (min * 60));
        sec += ''; min += '';
        while (min.length < 2) { min = '0' + min; }
        while (sec.length < 2) { sec = '0' + sec; }
        hr = (hr) ? ':' + hr : '';
        return min + ':' + sec;
    }

    function logout() {
        $$Login.Logout()
              .then(function () {
                  toaster.success("Your session has expired");
              });
        $state.go('login');
    }

    function keepAlive() {
        $$Login.keepAlive();
    }

}]).directive('fzIdle', [function () {

    return {
        restrict: 'A',
        replace: true,
        controller: 'fzIdleCtrl',
        link: function (scope, elm, attrs) {
            scope.start();
        }
    };
}]);

});

define(["angular", 'app/Shared/ngIdle/ngIdle-keepAlive', 'app/Shared/ngIdle/ngIdle-localStorage'], function () {
    'use strict';
    return angular.module('ngIdle.idle', ['ngIdle.keepalive', 'ngIdle.localStorage'])
  .provider('Idle', function () {
      var options = {
          idle: 20 * 60, // in seconds (default is 20min)
          timeout: 30, // in seconds (default is 30sec)
          autoResume: 'idle', // lets events automatically resume (unsets idle state/resets warning)
          interrupt: 'mousemove keydown DOMMouseScroll mousewheel mousedown touchstart touchmove scroll',
          keepalive: false
      };

      /**
       *  Sets the number of seconds a user can be idle before they are considered timed out.
       *  @param {Number|Boolean} seconds A positive number representing seconds OR 0 or false to disable this feature.
       */
      var setTimeout = this.timeout = function (seconds) {
          if (seconds === false) options.timeout = 0;
          else if (angular.isNumber(seconds) && seconds >= 0) options.timeout = seconds;
          else throw new Error('Timeout must be zero or false to disable the feature, or a positive integer (in seconds) to enable it.');
      };

      this.interrupt = function (events) {
          options.interrupt = events;
      };
     
      var setIdle = this.idle = function (seconds) {
          if (seconds <= 0) throw new Error('Idle must be a value in seconds, greater than 0.');

          options.idle = seconds;
      };

      this.autoResume = function (value) {
          if (value === true) options.autoResume = 'idle';
          else if (value === false) options.autoResume = 'off';
          else options.autoResume = value;
      };

      this.keepalive = function (enabled) {
          options.keepalive = enabled === true;
      };

      this.$get = ['$interval', '$log', '$rootScope', '$document', 'Keepalive', 'IdleLocalStorage', '$window',
        function ($interval, $log, $rootScope, $document, Keepalive, LocalStorage, $window) {
            var state = {
                idle: null,
                timeout: null,
                idling: false,
                running: false,
                countdown: null
            };

            var id = new Date().getTime();

            function startKeepalive() {
                if (!options.keepalive) return;

                if (state.running) Keepalive.ping();

                Keepalive.start();
            }

            function stopKeepalive() {
                if (!options.keepalive) return;

                Keepalive.stop();
            }

            function toggleState() {
                state.idling = !state.idling;
                var name = state.idling ? 'Start' : 'End';

                $rootScope.$broadcast('Idle' + name);

                if (state.idling) {
                    stopKeepalive();
                    if (options.timeout) {
                        state.countdown = options.timeout;
                        countdown();
                        state.timeout = $interval(countdown, 1000, options.timeout, false);
                    }
                } else {
                    startKeepalive();
                }

                $interval.cancel(state.idle);
            }

            function countdown() {
                // countdown has expired, so signal timeout
                if (state.countdown <= 0) {
                    timeout();
                    return;
                }

                // countdown hasn't reached zero, so warn and decrement
                $rootScope.$broadcast('IdleWarn', state.countdown);
                state.countdown--;
            }

            function timeout() {
                stopKeepalive();
                $interval.cancel(state.idle);
                $interval.cancel(state.timeout);

                state.idling = true;
                state.running = false;
                state.countdown = 0;

                $rootScope.$broadcast('IdleTimeout');
            }

            function changeOption(self, fn, value) {
                var reset = self.running();

                self.unwatch();
                fn(value);
                if (reset) self.watch();
            }

            function getExpiry() {
                var obj = LocalStorage.get('expiry');

                return obj && obj.time ? new Date(obj.time) : null;
            }

            function setExpiry(date) {
                if (!date) LocalStorage.remove('expiry');
                else LocalStorage.set('expiry', { id: id, time: date });
            }

            var svc = {
                _options: function () {
                    return options;
                },
                _getNow: function () {
                    return new Date();
                },
                getIdle: function () {
                    return options.idle;
                },
                getTimeout: function () {
                    return options.timeout;
                },
                setIdle: function (seconds) {
                    changeOption(this, setIdle, seconds);
                },
                setTimeout: function (seconds) {
                    changeOption(this, setTimeout, seconds);
                },
                isExpired: function () {
                    var expiry = getExpiry();
                    return expiry !== null && expiry <= this._getNow();
                },
                running: function () {
                    return state.running;
                },
                idling: function () {
                    return state.idling;
                },
                watch: function (noExpiryUpdate) {
                    $interval.cancel(state.idle);
                    $interval.cancel(state.timeout);

                    // calculate the absolute expiry date, as added insurance against a browser sleeping or paused in the background
                    var timeout = !options.timeout ? 0 : options.timeout;
                    if (!noExpiryUpdate) setExpiry(new Date(new Date().getTime() + ((options.idle + timeout) * 1000)));

                    if (state.idling) toggleState(); // clears the idle state if currently idling
                    else if (!state.running) startKeepalive(); // if about to run, start keep alive

                    state.running = true;

                    state.idle = $interval(toggleState, options.idle * 1000, 0, false);
                },
                unwatch: function () {
                    $interval.cancel(state.idle);
                    $interval.cancel(state.timeout);

                    state.idling = false;
                    state.running = false;
                    setExpiry(null);

                    stopKeepalive();
                },
                interrupt: function (noExpiryUpdate) {
                    if (!state.running) return;

                    if (options.timeout && this.isExpired()) {
                        timeout();
                        return;
                    }

                    // note: you can no longer auto resume once we exceed the expiry; you will reset state by calling watch() manually
                    if (options.autoResume === 'idle' || (options.autoResume === 'notIdle' && !state.idling)) this.watch(noExpiryUpdate);
                },
                FzkeepAlive: function () {
                    $rootScope.$broadcast('fzIdle-keepAlive');
                },
                FzLogout: function () {
                    $rootScope.$broadcast('fzIdle-logout');
                }
            };

            $document.find('html').on(options.interrupt, function (event) {
                if (event.type === 'mousemove' && event.originalEvent && event.originalEvent.movementX === 0 && event.originalEvent.movementY === 0) {
                    return; // Fix for Chrome desktop notifications, triggering mousemove event.
                }

                /*
                  note:
                    webkit fires fake mousemove events when the user has done nothing, so the idle will never time out while the cursor is over the webpage
                    Original webkit bug report which caused this issue:
                      https://bugs.webkit.org/show_bug.cgi?id=17052
                    Chromium bug reports for issue:
                      https://code.google.com/p/chromium/issues/detail?id=5598
                      https://code.google.com/p/chromium/issues/detail?id=241476
                      https://code.google.com/p/chromium/issues/detail?id=317007
                */
                if (event.type !== 'mousemove' || angular.isUndefined(event.movementX) || (event.movementX || event.movementY)) {
                    svc.interrupt();
                }
            });

            var wrap = function (event) {
                if (event.key === 'ngIdle.status')
                {
                    var val = angular.fromJson(event.newValue);
                    if (val.status === 'keepAlive') {
                        svc.FzkeepAlive();
                    }
                    if (val.status === 'logout') {
                        svc.FzLogout();
                    }
                }
               

                if (event.key === 'ngIdle.expiry' && event.newValue && event.newValue !== event.oldValue) {
                    var val = angular.fromJson(event.newValue);
                    if (val.id === id) return;
                    svc.interrupt(true);
                }
            };

            if ($window.addEventListener) $window.addEventListener('storage', wrap, false);
            else $window.attachEvent('onstorage', wrap);

            return svc;
        }
      ];
  });
});
define(["angular"], function () {
    'use strict';
    return angular.module('ngIdle.keepalive', [])
         .provider('Keepalive', function () {
             var options = {
                 http: null,
                 interval: 10 * 60
             };

             this.http = function (value) {
                 if (!value) throw new Error('Argument must be a string containing a URL, or an object containing the HTTP request configuration.');
                 if (angular.isString(value)) {
                     value = {
                         url: value,
                         method: 'GET'
                     };
                 }

                 value.cache = false;

                 options.http = value;
             };

             var setInterval = this.interval = function (seconds) {
                 seconds = parseInt(seconds);

                 if (isNaN(seconds) || seconds <= 0) throw new Error('Interval must be expressed in seconds and be greater than 0.');
                 options.interval = seconds;
             };

             this.$get = ['$rootScope', '$log', '$interval', '$http',
               function ($rootScope, $log, $interval, $http) {

                   var state = {
                       ping: null
                   };

                   function handleResponse(data, status) {
                       $rootScope.$broadcast('KeepaliveResponse', data, status);
                   }

                   function ping() {
                       $rootScope.$broadcast('Keepalive');

                       if (angular.isObject(options.http)) {
                           $http(options.http)
                             .success(handleResponse)
                             .error(handleResponse);
                       }
                   }

                   return {
                       _options: function () {
                           return options;
                       },
                       setInterval: setInterval,
                       start: function () {
                           $interval.cancel(state.ping);

                           state.ping = $interval(ping, options.interval * 1000);
                           return state.ping;
                       },
                       stop: function () {
                           $interval.cancel(state.ping);
                       },
                       ping: function () {
                           ping();
                       }
                   };
               }
             ];
         });
});
define(["angular"], function () {
    'use strict';
    return angular.module('ngIdle.localStorage', [])
        .service('IdleStorageAccessor', ['$window', function ($window) {
            return {
                get: function () {
                    return $window.localStorage;
                }
            }
        }])
        .service('IdleLocalStorage', ['IdleStorageAccessor', function (IdleStorageAccessor) {
            function AlternativeStorage() {
                var storageMap = {};

                this.setItem = function (key, value) {
                    storageMap[key] = value;
                };

                this.getItem = function (key) {
                    if (typeof storageMap[key] !== 'undefined') {
                        return storageMap[key];
                    }
                    return null;
                };

                this.removeItem = function (key) {
                    storageMap[key] = undefined;
                };
            }

            function getStorage() {
                try {
                    var s = IdleStorageAccessor.get();
                    s.setItem('ngIdleStorage', '');
                    s.removeItem('ngIdleStorage');

                    return s;
                } catch (err) {
                    return new AlternativeStorage();
                }
            }

            // Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem
            // throw QuotaExceededError. We're going to detect this and just silently drop any calls to setItem
            // to avoid the entire page breaking, without having to do a check at each usage of Storage.
            var storage = getStorage();

            return {
                set: function (key, value) {
                    storage.setItem('ngIdle.' + key, angular.toJson(value));
                },
                get: function (key) {
                    return angular.fromJson(storage.getItem('ngIdle.' + key));
                },
                remove: function (key) {
                    storage.removeItem('ngIdle.' + key);
                },
                _wrapped: function () {
                    return storage;
                }
            };
        }]);
});
define(["angular", ], function() {

    function totimeFilter() {
        return function(input) {
            if (!angular.isUndefined(input) && input !== null) {
                var s = String(parseFloat(input).toFixed(2)).split('.');
                var trail = ' AM';
                var hour = parseInt(s[0]);
                if (input >= 13) {
                    hour = hour - 12;
                    s[0] = hour;
                }

                if (input >= 12 && input < 24) {
                    trail = ' PM';
                }

                if (s[0] < 10) {
                    s[0] = "0" + s[0];
                }

                if (s[0] == 0)
                    s[0] = 12;
                return s[0] + ':' + s[1] + trail;
            } else {
                return '';
            }
        };
    }
    return angular
        .module('totime', [])
        .filter('totime', totimeFilter);

});

/*!
 * See LICENSE in this repository for license information
 */
(function () {
    'use strict';
    /*jshint unused:false*/
    var xtForm = angular.module('xtForm', []);
    xtForm.directive('ngModel', ["xtFormConfig", "$rootScope", "$interpolate", "$document", "$timeout", function (xtFormConfig, $rootScope, $interpolate, $document, $timeout) {
        'use strict';

        var UNTOUCHED_CLASS = 'ng-untouched',
            TOUCHED_CLASS = 'ng-touched';

        return {
            require: ['ngModel', '^?xtForm', '^?form'],
            link: function (scope, element, attrs, ctrls) {

                var defaultErrors = xtFormConfig.getErrorMessages(),
                    ngModel = ctrls[0],
                    xtForm = ctrls[1],
                    form = ctrls[2],
                    setTouchedFn,
                    validationStrategyFn;

                /**
                 * Active the directive
                 */
                function activate() {

                    setTouchedFn = ngModel.$setTouched || setTouchedPolyfill;
                    validationStrategyFn = xtForm.getValidationStrategy();
                    ngModel.$untouched = true;

                    // add extensions to ngModel
                    var labelEl = $document[0].querySelectorAll('label[for="' + attrs.id + '"]');
                    angular.extend(ngModel, {
                        $focused: false,
                        $label: labelEl.length > 0 ? labelEl[0].innerText : '',
                        $xtErrors: []
                    });

                    scope.$on('XtForm.ForceErrorUpdate', updateErrors);
                }

                function getErrorMessageForKey(key) {
                    var attrKey = 'msg' + key[0].toUpperCase() + key.substring(1);

                    // use either the provided string as an interpolated attribute, or the default message
                    if (angular.isUndefined(attrs[attrKey]) && angular.isUndefined(defaultErrors[key])) {
                        return "";
                    }
                    return attrs[attrKey] ?
                        attrs[attrKey] :
                        $interpolate(defaultErrors[key])(attrs);
                }

                /**
                 * Sets the $xtErrors collection on validation change
                 */
                function updateErrors() {

                    $timeout(function () {
                        ngModel.$xtErrors = [];

                        if (angular.isDefined(attrs.customValidationFunction)) {
                            var result = scope.$eval(attrs.customValidationFunction);
                            ngModel.$setValidity('customValidationFunction', result);
                        }

                        angular.forEach(ngModel.$error, function (value, key) {
                            var showErrors = value && validationStrategyFn(form, ngModel);
                            if (showErrors) {
                                var error = {
                                    key: key,
                                    message: getErrorMessageForKey(key)
                                };

                                // This is a bit of hack right now to ensure that data type validation errors are shown
                                // in priority over the required message if both fail.
                                // TODO will likely need to introduce priorities of error messages
                                if (key === 'required') {
                                    ngModel.$xtErrors.push(error);
                                } else {
                                    ngModel.$xtErrors.unshift(error);
                                }
                            }
                        });

                        $rootScope.$broadcast('XtForm.ErrorsUpdated', ngModel);
                    });
                }

                // Polyfill for $touched in AngularJS < 1.3
                function setTouchedPolyfill() {
                    ngModel.$touched = true;
                    ngModel.$untouched = false;
                    element.addClass(TOUCHED_CLASS).removeClass(UNTOUCHED_CLASS);
                }

                if (xtForm) {
                    activate();
                }
            }
        };
    }]);
    xtForm
        .directive('xtForm', ["$timeout", function ($timeout) {
            'use strict';

            return {
                require: '',
                priority: -1,
                controller: 'XtFormController',
                controllerAs: 'xtForm',
                link: function (scope, element, attrs, xtForm) {
                    scope.$on('xtreset', function () {
                        $timeout(function () {
                            xtForm.reset();
                        }, 0);

                    })
                }
            };
        }])
        .controller('XtFormController', ["$scope", "$element", "$attrs", "xtFormConfig", "$window", "$timeout", "$q", function ($scope, $element, $attrs, xtFormConfig, $window, $timeout, $q) {
            'use strict';

            var vm = this,
                form = $element.controller('form'),
                validationStrategy = $attrs.strategy ?
                    xtFormConfig.getValidationStrategy($attrs.strategy) :
                    xtFormConfig.getDefaultValidationStrategy();

            //polyfill for setSubmitted pre 1.3
            function setSubmitted() {
                if (angular.isFunction(form.$setSubmitted)) {
                    form.$setSubmitted();
                    return;
                }

                form.$submitted = true;
                $element.addClass('ng-submitted');
            }

            function setUnsubmitted() {
                if (angular.isFunction(form.$setSubmitted)) {
                    return;
                }
                form.$submitted = false;
                $element.removeClass('ng-submitted');
            }

            angular.extend(vm, {

                form: form,

                getValidationStrategy: function () {
                    return validationStrategy;
                },

                tooltipTrigger: $attrs.tooltipTrigger,

                submit: function () {
                    // remove .has error element from all form elements.
                    setSubmitted();
                    var deferred = $q.defer();
                    // focus first error if required
                    if (form.$invalid && $attrs.focusError) {
                        $window.setTimeout(function () {
                            $element.find('.ng-invalid:input:visible:first').focus();
                        });
                    }

                    $scope.$broadcast('XtForm.ForceErrorUpdate', null, 'submit');
                    $scope.$broadcast('XtForm.HideServerError');
                    $timeout(function () {

                        angular.forEach($element.find('input,select,.select2,textarea'), function (value) {
                            if ($(value).hasClass("ng-invalid")) {
                                $(value).addClass("has-error");
                            }

                            if ($(value).hasClass("has-error") && $(value).hasClass("ng-valid")) {
                                $(value).removeClass("has-error");
                            }
                        });
                        deferred.resolve();
                    }, 0);

                    return deferred.promise;
                },

                reset: function () {
                    vm.form.$setPristine();
                    vm.form.$setUntouched();
                    setUnsubmitted();
                    $timeout(function () {

                        angular.forEach($element.find('input,select,.select2,textarea'), function (value) {
                            $(value).removeClass("has-error");
                        });
                    }, 0);

                    $scope.$broadcast('XtForm.ForceErrorUpdate', null, 'reset');
                    $scope.$broadcast('XtForm.HideServerError');
                }

            });
        }]);
    xtForm.provider('xtFormConfig', function () {
        'use strict';

        var self = this,
            _errors = {
                minlength: 'Needs to be at least {{ngMinlength}} characters long',
                maxlength: 'Can be no longer than {{ngMaxlength}} characters long',
                required: 'This field is required',
                number: 'Must be a number',
                min: 'Must be at least {{min}}',
                max: 'Must be no greater than {{max}}',
                email: 'Must be a valid E-mail address',
                pattern: 'Illegal value',
                url: 'Must be a valid URL',
                date: 'Must be a valid date',
                datetimelocal: 'Must be a valid date',
                time: 'Must be a valid time',
                week: 'Must be a valid week',
                month: 'Must be a valid month',
                $$server: 'An error has occurred'
            },
            _validationStrategyFn;

        angular.extend(self, {

            $validationStrategies: {
                invalid: function (form) {
                    return form.$invalid;
                },
                submitted: function (form) {
                    return form.$invalid && form.$submitted;
                },
                dirty: function (form, ngModel) {
                    return ngModel.$invalid && ngModel.$dirty;
                },
                dirtyOrSubmitted: function (form, ngModel) {
                    return ngModel.$invalid && (form.$submitted || ngModel.$dirty);
                },
                focusedAndDirtyOrSubmitted: function (form, ngModel) {
                    return ngModel.$invalid && (ngModel.$focused && (ngModel.$dirty || form.$submitted));
                },
                dirtyAndFocusedOrSubmitted: function (form, ngModel) {
                    return ngModel.$invalid && (form.$submitted || (ngModel.$dirty && ngModel.$focused));
                }
            },

            addValidationStrategy: function (name, fn) {
                self.$validationStrategies[name] = fn;
            },

            setDefaultValidationStrategy: function (strategy) {
                if (!self.$validationStrategies[strategy]) {
                    throw new Error('Could not find validation strategy by name: ' + strategy);
                }
                _validationStrategyFn = self.$validationStrategies[strategy];
            },

            setErrorMessages: function (errors) {
                angular.extend(_errors, errors);
            }

        });

        this.$get = function () {
            return {
                getErrorMessages: function () {
                    return angular.copy(_errors);
                },
                getValidationStrategy: function (name) {
                    if (!self.$validationStrategies[name]) {
                        throw new Error('Could not find validation strategy by name: ' + name);
                    }
                    return self.$validationStrategies[name];
                },
                getDefaultValidationStrategy: function () {
                    return _validationStrategyFn;
                }
            };
        };

        self.setDefaultValidationStrategy('dirtyOrSubmitted');
    });
    xtForm.directive('xtServerValidationSummary', ["$templateCache", "$timeout", function ($templateCache, $timeout) {
        'use strict';

        return {
            require: ['^xtForm', '^form'],
            restrict: 'E',
            replace: true,
            scope: true,
            template: "<div class='server-error error-wrapper ng-hide' ></div>",
            link: function (scope, element, attrs, ctrls) {
            }
        };
    }]);

    xtForm.directive('xtFormServer', ["$templateCache", "$rootScope", "$timeout", function ($templateCache, $rootScope, $timeout) {
        'use strict';
        return {
            require: ['^xtForm', '^form'],
            restrict: 'A',
            replace: false,
            scope: false,
            link: function (scope, element, attrs, ctrls) {
                var serverMessages = '';
                function hideError() {
                    var errDiv = $(element.closest("form")).find('div.server-error');
                    $(errDiv).addClass('ng-hide');
                }

                function showError(event, args) {
                    if (args && args.formName && attrs.name == args.formName) {
                        var errDiv = $(element.closest("form")).find('div.server-error');
                        $(errDiv).removeClass('ng-hide');
                    }
                }
                scope.$on('XtForm.HideServerError', hideError);
                scope.$on('XtForm.ShowServerError', showError);

                attrs.$observe('xtFormServer', function (value) {
                    $timeout(function () {
                        value = scope.$eval(value);
                        if (angular.isDefined(value) && value.length > 0) {
                            var frm = $(element.closest("form"));
                            serverMessages = '';
                            var serverErrodDiv = frm.find('div.server-error');
                            $(serverErrodDiv).html('');
                            angular.forEach(value, function (val) {
                                for (var key in val) {
                                    var elm = frm.find('[server-id="' + key + '"]');
                                    $(elm).addClass('has-error');
                                    serverMessages = serverMessages + "<label class='error'>" + val[key] + "</label>"
                                }
                            });
                            $(serverErrodDiv).html(serverMessages);
                            $rootScope.$broadcast('XtForm.ShowServerError', { formName: attrs.name });
                        }
                    });
                });
            }
        };
    }]);

    xtForm.directive('customValidationFunction', ["$rootScope", "$parse", '$timeout', function ($rootScope, $parse, $timeout) {
        'use strict';

        return {
            require: '?ngModel',
            restrict: 'A',
            replace: false,
            link: function (scope, element, attrs, ctrls) {

                $timeout(function () {
                    var modelGetter = $parse(attrs['ngModel']);
                    var currencyMaskPresent = angular.isDefined(attrs.currencyMask);
                    ctrls.$validators.customValidationFunction = function (modelValue, viewValue) {
                        var modelSetter = modelGetter.assign;
                        //TODO : This needs to be refractored...
                        if (currencyMaskPresent && viewValue) {
                            viewValue = viewValue.replace(/,/g, "");
                        }

                        modelSetter(scope, viewValue);
                        return scope.$eval(attrs.customValidationFunction);
                    };
                })
            }
        };
    }])

    xtForm.directive('xtValidationSummary', ["$templateCache", "$timeout", function ($templateCache, $timeout) {
        'use strict';

        return {
            require: ['^xtForm', '^form'],
            restrict: 'EA',
            replace: true,
            scope: true,
            template: function (element, attrs) {
                return $templateCache.get(attrs.templateUrl || 'xtForm/summary/validationSummary.html');
            },
            link: function (scope, element, attrs, ctrls) {

                var form = ctrls[1];
                scope.showLabel = (attrs.showLabel === 'true') || angular.isUndefined(attrs.showLabel);
                scope.showErrors = false;
                function redrawErrors() {
                    scope.errors = [];
                    angular.forEach(form, function (ngModel, ngModelKey) {
                        if (ngModelKey[0] !== '$') {

                            // can show one error for each input, or multiple
                            var noOfErrors = attrs.multiple ? ngModel.$xtErrors.length : 1, errors=[];
                            if(angular.isDefined(ngModel)&&angular.isDefined(ngModel.$xtErrors)){
                                errors = ngModel.$xtErrors.slice(0, noOfErrors);
                            }

                            angular.forEach(errors, function (value) {
                                scope.errors.push({
                                    key: value.key,
                                    label: ngModel.$label,
                                    message: value.message
                                });
                            });
                        }
                    });

                    scope.showErrors = scope.errors.length > 0;
                }
                scope.$on('XtForm.ErrorsUpdated', redrawErrors);
            }
        };
    }]);
})();

/*global angular,define*/

define(['angular',
  
    'app/Shared/fzClose/Directives/fz-close',
    'app/Shared/Services/lookup-service',
    'app/Shared/fzSubmit/Directives/fz-submit',
    'app/Shared/fzCancel/Directives/fz-cancel',
    'toaster',
    'app/Shared/fzGrid/Directives/fz-grid',
    'app/Shared/fzFile/Directives/fz-file',
    'app/User/Student/Attendance/Shared/attendance-service',
    'app/User/Student/Attendance/absent-list-service'
], function () {
    return angular.module("eruditeApp.Student.AbsentListController", ['toaster'])
    .controller('AbsentListController', ['$scope', '$element', '$$Attendance', 'toaster', '$rootScope', '$document', '$$Lookup', '$$AbsentList',
           function ($scope, $element, $$Attendance, toaster, $rootScope, $document, $$Lookup, $$AbsentList) {

               $scope.uiState = {};
               $scope.uploadModel = {};
               $scope.uiState.Divisions = [{ DivisionID: null, DivisionName: 'Select' }];
               $scope.uiState.Batches = [{ BatchID: null, BatchStartYear: 'Select' }];
               $scope.uiState.Courses = [{ CourseID: null, CourseName: 'Select' }];


               //Get All Divisions
               function getAllDivisions() {
                   $$Lookup.getAllDivisions()
                   .success(function (resp) {
                       //$scope.uiState.Divisions={DivisionID:null,DivisionName:'Select'}
                       $scope.uiState.Divisions.push.apply($scope.uiState.Divisions, resp);
                   })
                   .error(function () {
                       console.log("Could't get all divisions")
                   })
               }
               //Get all Batches
               function getAllBatches() {
                   $$Lookup.getAllBatches()
                   .success(function (resp) {
                       $scope.uiState.Batches.push.apply($scope.uiState.Batches, resp);
                   })
                   .error(function () {
                       console.log("Could't get all Batches")
                   })
               }
               //Get all Courses
               function getAllCourses() {
                   $$Lookup.getAllCourses()
                   .success(function (resp) {
                       $scope.uiState.Courses.push.apply($scope.uiState.Courses, resp);
                   })
                   .error(function () {
                       console.log("Could't get all Courses")
                   })
               }
               getAllDivisions();
               getAllBatches();
               getAllCourses();


               $scope.attendanceModel = $scope.attendanceModel || {};
               $scope.attendanceModel.Date = new Date();

               $scope.ClassScheduleChange = function (classScheduleID) {
                   $scope.attendanceModel.ClassScheduleID = classScheduleID;
                   $scope.GetStudentAttendanceDetails();
               }

               $scope.GetStudentAttendanceDetails = function () {

                   var model = {
                       BatchID: $scope.attendanceModel.BatchID,
                       CourseID: $scope.attendanceModel.CourseID,
                       ClassScheduleID: $scope.attendanceModel.ClassScheduleID,
                       DivisionID: 1,
                       CollageID: 10001
                   };
                   if (model.ClassScheduleID > 0) {

                       $$Attendance.getStudentAttendanceDetails(model)
                     .success(function (result) {
                         var isNeW = true;
                         result.Attendance.forEach(function (attend) {
                             if (attend.AttendanceID > 0) {
                                 isNeW = false;
                             }
                         });
                         if (isNeW) {
                             result.Attendance.forEach(function (attend) {
                                 if (attend.AttendanceID == 0) {
                                     attend.IsStudentAttended = true;

                                 }
                             });
                         }
                         $scope.Attendance = result.Attendance;
                         console.log(result);
                     })


                     .error(function (error) {
                         console.log(error);
                         toaster.error("Something went wrong");
                     });
                   }
                   else {
                       $scope.Attendance = null;

                   }
               };





               $scope.GetClassScheduleDetailsForDay = function ( model) {

                
                   $$Attendance.getClassscheduleDetails(model)
                      .success(function (resp) {
                          $scope.ClassSchedules = resp;
                         
                      })
                      .error(function (error) {
                         
                          console.log(error);
                          toaster.error("Something went wrong");
                      });                

               };



               $scope.GetStudentAbsentDetailsForDay = function () {
                   var model = {
                       BatchID: $scope.attendanceModel.BatchID,
                       CourseID: $scope.attendanceModel.CourseID,
                       Date: $scope.attendanceModel.Date,
                       DivisionID: 1,
                       CollageID: 10001
                   };
                   $scope.GetClassScheduleDetailsForDay(model);
                   $$AbsentList.getStudentAbsentDetailsForDay(model)
                      .success(function (resp) {
                          $scope.Attendance = resp;                        
                      })
                      .error(function (error) {                          
                          console.log(error);
                          toaster.error("Something went wrong");
                      });

               }

               $scope.AddAbsentNotificationToQueue = function () {                   
                   console.log($scope.Attendance);
                   $$AbsentList.addAbsentNotificationToQueue($scope.Attendance)
                    .success(function (resp) {
                        toaster.success("Attendance Notification saved successfully");
                    })
                    .error(function (error) {
                        console.log(error);
                        toaster.error("Something went wrong");
                    });
               };
           }
    ]);
});

/*global angular,console,state*/
define(["angular",
    'app/eruditeconfig',
 'app/User/Student/Shared/student-model'], function () {
     'use strict';
     return angular.module('eruditeApp.Student.AbsentListService', ['ngEnter'])
        .service('$$AbsentList', ['$q', '$http', 'ERUDITE_CONFIG', function ($q, $http, ERUDITE_CONFIG) {
            var apiUrl = ERUDITE_CONFIG.baseUrl;

            this.getStudentAbsentDetailsForDay = function (model) {
                var deferred = $q.defer(),
                  promise = deferred.promise;

                $http.post(apiUrl + 'student/attendance/get-all-student-attendance-details-for-day', model)
                .then(function (resp) {
                    deferred.resolve(resp.data);
                })
                .catch(function (error) {
                    deferred.reject(error.data);
                });
                promise.success = function (callback) {
                    promise.then(callback);
                    return promise;
                };
                promise.error = function (callback) {
                    promise.catch(callback);
                    return promise;
                };
                return promise;
            };
            this.addAbsentNotificationToQueue = function (model) {
                var deferred = $q.defer(),
                  promise = deferred.promise;

                $http.post(apiUrl + 'student/attendance/add-student-absent-details-to-notification-queue', model)
                .then(function (resp) {
                    deferred.resolve(resp.data);
                })
                .catch(function (error) {
                    deferred.reject(error.data);
                });
                promise.success = function (callback) {
                    promise.then(callback);
                    return promise;
                };
                promise.error = function (callback) {
                    promise.catch(callback);
                    return promise;
                };
                return promise;
            };


        }]);
 });
/*global angular,define*/

define(['angular',
    'app/Shared/Upload/documents-service',
    'app/Shared/fzClose/Directives/fz-close',
    'app/Shared/Services/lookup-service',
    'app/Shared/fzSubmit/Directives/fz-submit',
    'app/Shared/fzCancel/Directives/fz-cancel',
    'toaster',
    'app/Shared/fzGrid/Directives/fz-grid',
    'app/Shared/fzFile/Directives/fz-file',
    'app/User/Student/Attendance/Shared/attendance-service',
    'app/User/Student/Attendance/record-attendance-service'
], function () {
    return angular.module("eruditeApp.Student.AttendanceRecordController", ['toaster'])
    .controller('AttendanceRecordController', ['$scope', '$element', '$$Attendance', 'toaster', '$rootScope', '$document', '$$Lookup','$$AttendanceRecord',
           function ($scope, $element, $$Attendance, toaster, $rootScope, $document, $$Lookup, $$AttendanceRecord) {
              
               $scope.uiState = {};
               $scope.uploadModel = {};
               $scope.uiState.Divisions = [{ DivisionID: null, DivisionName: 'Select' }];
               $scope.uiState.Batches = [{ BatchID: null, BatchStartYear: 'Select' }];
               $scope.uiState.Courses = [{ CourseID: null, CourseName: 'Select' }];


               //Get All Divisions
               function getAllDivisions() {
                   $$Lookup.getAllDivisions()
                   .success(function (resp) {
                       //$scope.uiState.Divisions={DivisionID:null,DivisionName:'Select'}
                       $scope.uiState.Divisions.push.apply($scope.uiState.Divisions, resp);
                   })
                   .error(function () {
                       console.log("Could't get all divisions")
                   })
               }
               //Get all Batches
               function getAllBatches() {
                   $$Lookup.getAllBatches()
                   .success(function (resp) {
                       $scope.uiState.Batches.push.apply($scope.uiState.Batches, resp);
                   })
                   .error(function () {
                       console.log("Could't get all Batches")
                   })
               }
               //Get all Courses
               function getAllCourses() {
                   $$Lookup.getAllCourses()
                   .success(function (resp) {
                       $scope.uiState.Courses.push.apply($scope.uiState.Courses, resp);
                   })
                   .error(function () {
                       console.log("Could't get all Courses")
                   })
               }
               getAllDivisions();
               getAllBatches();
               getAllCourses();


               //$scope.model = {
               //    title: 'Uploads',
               //    PageIndex: 1,
               //    PageSize: 15,
               //    filters: {},
               //    data: [],
               //    //infiniteScroll: true

               //};

               $scope.attendanceModel = $scope.attendanceModel || {};
               $scope.attendanceModel.Date = new Date();

               //$scope.onLoad = function () {
               //    //$$Documents.UploadGrid({
               //    //    Filter: $scope.model.filters,
               //    //    PageIndex: $scope.model.PageIndex,
               //    //    PageSize: $scope.model.PageSize
               //    //})
               //    //  .success(function (resp) {
               //    //      $scope.model.data = resp.Result;
               //    //      $scope.model.gridTotalRecords = resp.TotalRecords;
               //    //      $scope.$broadcast('reformGrid');
               //    //  })
               //    //  .error(function (error) {

               //    //      toaster.error("Something went wrong while loading the grid");
               //    //  });
               //};
               //$scope.$on('filterChanged', function () {
               //    $scope.model.data = [];
               //    $scope.model.PageIndex = 1;
               //});


               $scope.ClassScheduleChange = function (classScheduleID) {
                   $scope.attendanceModel.ClassScheduleID = classScheduleID;
                   $scope.GetStudentAttendanceDetails();
               }
               $scope.GetStudentAttendanceDetails = function () {

                   var model = {
                       BatchID: $scope.attendanceModel.BatchID,
                       CourseID: $scope.attendanceModel.CourseID,
                       ClassScheduleID: $scope.attendanceModel.ClassScheduleID,
                       DivisionID: 1,
                       CollageID: 10001
                   };
                   if (model.ClassScheduleID > 0) {

                       $$Attendance.getStudentAttendanceDetails(model)
                     .success(function (result) {
                         var isNeW = true;
                         result.Attendance.forEach(function (attend) {
                             if (attend.AttendanceID > 0) {
                                 isNeW = false;
                             }
                         });
                         if (isNeW) {
                             result.Attendance.forEach(function (attend) {
                                 if (attend.AttendanceID == 0) {
                                     attend.IsStudentAttended = true;

                                 }
                             });
                         }
                         $scope.Attendance = result.Attendance;
                         console.log(result);
                     })
                
                    
                     .error(function (error) {
                         console.log(error);
                         toaster.error("Something went wrong");
                     });
                   }
                   else {
                       $scope.Attendance = null;

                   }                    
               };


               $scope.GetClassScheduleDetailsForDay = function () {

                   var model = {
                       BatchID: $scope.attendanceModel.BatchID,
                       CourseID: $scope.attendanceModel.CourseID,
                       Date: $scope.attendanceModel.Date,
                       DivisionID: 1,
                       CollageID: 10001
                   };
                   $$Attendance.getClassscheduleDetails(model)
                      .success(function (resp) {
                          $scope.ClassSchedules = resp;
                      })
                      .error(function (error) {
                          console.log(error);
                          toaster.error("Something went wrong");
                      });                 
                   
               };

               $scope.SaveStudentAttendanceDetails = function () {
                   debugger;

                   console.log($scope.Attendance);
                   $$AttendanceRecord.saveStudentAttendanceDetails($scope.Attendance)
                    .success(function (resp) {
                        toaster.success("Attendance saved successfully");
                    })
                    .error(function (error) {
                        console.log(error);
                        toaster.error("Something went wrong");
                    });                 
               };
           }
   ]);
});

/*global angular,console,state*/
define(["angular",
    'app/eruditeconfig',
 'app/User/Student/Shared/student-model'], function () {
     'use strict';
     return angular.module('eruditeApp.Student.AttendanceRecordService', ['ngEnter'])
        .service('$$AttendanceRecord', ['$q', '$http', 'ERUDITE_CONFIG', function ($q, $http, ERUDITE_CONFIG) {
            var apiUrl = ERUDITE_CONFIG.baseUrl;
            this.saveStudentAttendanceDetails = function (model) {
                var deferred = $q.defer(),
                  promise = deferred.promise;

                $http.post(apiUrl + 'student/attendance/save-student-attendance-details', model)
                .then(function (resp) {
                    deferred.resolve(resp.data);
                })
                .catch(function (error) {
                    deferred.reject(error.data);
                });
                promise.success = function (callback) {
                    promise.then(callback);
                    return promise;
                };
                promise.error = function (callback) {
                    promise.catch(callback);
                    return promise;
                };
                return promise;
            };     






        }]);
 });
/*global angular,console,state*/
define(["angular",
    'app/eruditeconfig',
 'app/User/Student/Shared/student-model' ], function () {
        'use strict';
        return angular.module('eruditeApp.Student.StudentBasicInfoService', ['ngEnter'])
           .service('$$StudentBasicInfo', ['$q', '$http', 'ERUDITE_CONFIG', function ($q, $http, ERUDITE_CONFIG) {
               var apiUrl = ERUDITE_CONFIG.baseUrl;
               this.getAllStudents = function (gridRequest) {                   
                   var deferred = $q.defer(),
                     promise = deferred.promise;
                   
                   $http.post(apiUrl + 'student/get-all', gridRequest)
                   .then(function (resp) {
                       deferred.resolve(resp.data);
                   })
                   .catch(function (error) {
                       deferred.reject(error.data);
                   });
                   promise.success = function (callback) {
                       promise.then(callback);
                       return promise;
                   };
                   promise.error = function (callback) {
                       promise.catch(callback);
                       return promise;
                   };
                   return promise;
               };
               this.getStudentById = function (id) {
                   var deferred = $q.defer(),
                       promise = deferred.promise;
                   $http.get(apiUrl + 'student/basic-information/get/' + id)
                   .then(function (resp) {
                       var student = new Student(resp.data);
                       deferred.resolve(student);
                   })
                   .catch(function (error) {
                       deferred.reject(error);
                   });
                   promise.success = function (callback) {
                       promise.then(callback);
                       return promise;
                   };
                   promise.error = function (callback) {
                       promise.catch(callback);
                       return promise;
                   };
                   return promise;
               };
             
           }]);
    });

/// <reference path="../../Patient/patient-config.js" />
/*global angular,console,state*/

define(["angular",
    'app/Shared/Directives/header-directive',
    'app/User/Student/BasicInformation/student-basic-info-service',
    'app/Shared/fzGrid/Directives/fz-grid',
    'app/Shared/Directives/ng-enter',
    'app/Patient/patient-config',

], function () {
    'use strict';
    return angular.module('eruditeApp.Student.StudentGridController', ['eruditeApp.Student.StudentBasicInfoService', 'ngEnter'])
        .controller('StudentGridController', ['$scope', '$$StudentBasicInfo', '$state', 'toaster',
            function ($scope, $$StudentBasicInfo, $state, toaster) {
                $scope.model = {
                    title: 'Students',
                    PageIndex: 1,
                    PageSize: 15,
                    filters: {},
                    data: []
                };
                $scope.isEditable = false;
                $scope.onLoad = function () {
                    $$StudentBasicInfo.getAllStudents({
                        Filter: $scope.model.filters,
                        PageIndex: $scope.model.PageIndex,
                        PageSize: $scope.model.PageSize
                    })
                      .success(function (resp) {
                          $scope.model.data = resp.Result;
                          $scope.model.gridTotalRecords = resp.TotalRecords;
                          $scope.$broadcast('reformGrid');
                      })
                      .error(function (error) {
                          console.log(error);
                          toaster.error("Something went wrong");
                      });
                };

                $scope.toggleViewMode = function () {
                    $scope.isEditable = !$scope.isEditable;                  
                };
                $scope.getStudents = function (id) {
                    $scope.isEditable = false;
                    if (id && id.StudentID) {
                        getStudentById(id.StudentID);
                    }
                };
                function getStudentById(studentId) {
                    $$StudentBasicInfo.getStudentById(studentId)
                        .success(function (student) {                            
                            $scope.Student = angular.copy(student);
                            $scope.master = angular.copy($scope.Student);                         
                        })
                        .error(function (err) {
                            toaster.error("Something went wrong, could not find the student for editing");
                        });
                }
            }]);
});


/*student  model*/
function Student(p) {
    var student = p || {};
    this.StudentID = student.StudentID || 0;
    this.StudentIdentifier = student.StudentIdentifier || 0;
    this.Name = student.Name || "";
    this.DOB = student.DOB || "";
    this.Gender = student.Gender || "";
    this.PrimaryAddressID = student.PrimaryAddressID || 0;
    this.SecondaryAddressID = student.SecondaryAddressID || 0;
    this.AddressDetail = new Address(student.AddressDetail);
    this.Mobile = student.Mobile || "";
    this.Email = student.Email || "";

    this.RollNo = student.RollNo || "";
    this.RegistrationNo = student.RegistrationNo || "";
    this.BatchID = student.BatchID || 0;
    this.PrimaryAddressID = student.PrimaryAddressID || 0;
    this.RowVersionStamp = student.RowVersionStamp || "";
}
/*address model*/
function Address(addr) {
    var a = addr || {};
    this.AddressDetailID = a.AddressDetailID || 0;
    this.AddressLine1 = a.AddressLine1 || "";
    this.AddressLine2 = a.AddressLine2 || "";
    this.City = a.City || "";
    this.State = a.State || "";
    this.ZipCode = a.ZipCode || "";
}

//define(["angular", 'app/Patient/Shared/patient-service', 'app/Patient/Shared/patient-context-service' ], function () {
//    'use strict';

//    var patientInfoPaneController = ['$scope', '$$Patient', '$$PatientContext', 'toaster',
//        function ($scope, $$Patient, $$PatientContext, toaster) {
//            getpatientInfoPane($$PatientContext.$PatientID);
//            function getpatientInfoPane(patientID) {
//                $$Patient.getPatientInfoPane(patientID)
//                   .success(function (resp) {                     
//                       $scope.PatientInfoPane = resp;
//                   })
//                   .error(function (err) {
//                   });
//            }

//            $scope.$on('context-patient-edited', function () {
//                getpatientInfoPane($$PatientContext.$PatientID);
//            });
//        }];

//    return angular.module('eruditeApp.Shared.InfoPaneDirective', ['ui.router'])
//          .controller('patientInfoPaneController', patientInfoPaneController)
//      .directive('userInfoPane', [function () {
//          return {
//              restrict: 'E',
//              replace: true,
//              templateUrl: '/app/Shared/InfoPane/Templates/user-info-pane.html'
//          }
//      }])
//      .directive('patientInfoPane', [function () {
//          return {
//              restrict: 'E',
//              replace: true,
//              templateUrl: '/app/Shared/InfoPane/Templates/patient-info-pane.html',
//              controller: 'patientInfoPaneController'
//          }
//      }])
//      .directive('setupInfoPane', [function () {
//          return {
//              restrict: 'E',
//              replace: true,
//              templateUrl: '/app/Shared/InfoPane/Templates/setup-info-pane.html'
//          }
//      }]);
//});
angular.module('eruditeApp.Shared.LeftPaneController', [])
  .controller('AccordionCtrl', ['$scope', function($scope) {

    // $scope.isCollapsed = true;

    $scope.parentPrivilegeIDs = function(y) {
      return y.map(function(x) {
        return x.PrivilegeID;
      });
    };
  }])
  .controller('PrivilegeCtrl', ['$scope', function($scope) {
    $scope.hasPrivilege = false;
    console.log("privilege ctrl");
    var samplePermArray = [1, 2, 3];
    $scope.checkPrivilege = function(privilegeID) {
      console.log("start check");
      angular.forEach(samplePermArray, function(value, index) {
        if (value == privilegeID) {
          $scope.hasPrivilege = true;
          console.log("has privilege");
          console.log(value);
        }

      });
      console.log("end check");

    }
  }]);

define(['angular',
    'app/Shared/Services/login-service',
], function () {
    var LeftPaneController = ['$$Login', "$scope", "$rootScope", function ($$Login, $scope, $rootScope) {
        $scope.parentPrivilegeIDs = function (y) {
            return y.map(function (x) {
                return x.PrivilegeID;
            });
        };
        $scope.CheckPrivilege = function (id, privilege) {
            return $$Login.CheckPrivileges(id, privilege);
        };
    }];
    return angular.module('eruditeApp.Shared.LeftPaneDirective', [])
      .directive('leftPane', [function () {
          return {
              restrict: 'E',
              replace: true,
              templateUrl: '/app/Shared/LeftPane/Templates/leftPane.html',
              controller: LeftPaneController
          }
      }])
      .directive('accordion', ['$document', '$state', function ($document, $state) {
          return {
              restrict: 'E',
              scope: {
                  data: '='
              },
              templateUrl: '/app/Shared/LeftPane/Templates/accordion.html',
              controller: LeftPaneController,
              link: function (scope, element, attributes) {
                  for (var i in scope.data.SubSection) {
                      var route = scope.data.SubSection[i].Link;
                      if ($state.includes('**' + route)) {
                          element.addClass('open');
                      }
                  }
                  scope.accordionClick = function () {
                      if (element.hasClass('open')) {
                          $document.find('accordion .accordion-child').slideUp('fast', function () {
                              $document.find('accordion').removeClass('open');
                          });
                      } else {
                          $document.find('accordion .accordion-child').slideUp('fast', function () {
                              $document.find('accordion').removeClass('open');
                          });
                          element.find('.accordion-child').slideDown('fast', function () {
                              element.addClass('open');
                          });
                      }
                  }
              }
          }
      }])
      .directive('setupPane', [function () {
          return {
              restrict: 'E',
              replace: true,
              templateUrl: '/app/Shared/LeftPane/Templates/setupPane.html',
              controller: LeftPaneController
          }
      }])
      .directive('locationPane', [function () {
          return {
              restrict: 'E',
              replace: true,
              templateUrl: '/app/Shared/LeftPane/Templates/locationPane.html',
              controller: LeftPaneController
          }
      }])
      .directive('userPane', [function () {
          return {
              restrict: 'E',
              replace: true,
              templateUrl: '/app/Shared/LeftPane/Templates/userPane.html',
              controller: LeftPaneController
          }
      }])
      .directive('patientPane', [function () {
          return {
              restrict: 'E',
              replace: true,
              templateUrl: '/app/Shared/LeftPane/Templates/patientPane.html',
              controller: LeftPaneController
          }
      }]);
    
});
angular.module('eruditeApp.Header.AlertDirective', [])
.directive('navAlerts', [function () {
    return {
        restrict: 'E',
        controller: ['$scope', function($scope){
          $scope.menu = ["a", "b"];
        }],
        templateUrl: '/app/Shared/TopNavigation/Templates/alerts.html'
    }
}]);

define(['angular', 'xtForm'], function () {
    return angular.module('eruditeApp.Shared.FormCancelDirective', [])
    .directive('fzCancel', ['$parse', '$timeout', function ($parse, $timeout) {

        return {
            restrict: 'E',
            require: ['^?form', '^?xtForm'],
            replace: true,
            templateUrl: '/app/Shared/fzCancel/Templates/fz-cancel.html',
            link: function (scope, elm, attrs, ctrl) {
                var form = ctrl[0];
                var xtform = ctrl[1];
                var fn;
                elm.bind("click", function (event) {
                    $timeout(function () {
                      xtform.reset();

                            if (fn) {
                                fn(scope, { $event: event });
                            }

                    });
                });

                if (angular.isDefined(attrs.function)) {
                    fn = $parse(attrs['function']);
                }
            }
        };
    }]);
    });

define(['angular'], function () {
    return angular.module('eruditeApp.Shared.ModelCloseDirective', [])
    .directive('fzClose', ['$parse','$$DialogConfirm', function ($parse,$$DialogConfirm) {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: '/app/Shared/fzClose/Templates/fz-close.html',
            link: function (scope, elm, attrs, ctrl) {
                 scope.closeAction = function() {
	                var pristine = true;
	                angular.forEach(scope, function (value) {
	                    if (angular.isObject(value)) {
	                        if(value.hasOwnProperty('$$parentForm')){
							  if(value.$pristine == false){
							  	pristine = value.$pristine;
							  }
							}
	                    }
	                });
	                if(!pristine){
	                	showDialog();
	                }
	                else{
		               scope.closeThisDialog();
	                }
                };
                function showDialog(){
		        	$$DialogConfirm.open('Warning', 'Are you sure you want to discard the changes?')
		            .then(function (value) {
		                if (value) {
		                	scope.closeThisDialog();
		                }
		            }, function (error) {
		                console.log("fz-close",error);
		            });
		        }

            }
        };

    }]);
});

define(['angular', 'jquery-ui', 'xtForm', 'app/Shared/Services/utility.service'], function () {
    return angular.module("eruditeApp.Shared.DateElement", ['eruditeApp.Shared.UtilityService'])
      .directive('fzDateE', ['$$Utility', '$timeout', function ($$Utility, $timeout) {
          return {
              restrict: 'E',
              require: '^?ngModel',
              replace: true,
              scope: {
                  model: "=dateModel",
                  datechange: "&"
              },
              templateUrl: '/app/Shared/fzDate/Templates/fz-date-e.html',
              compile: function (elem, attr) {

                  // ADD GLOBAL FUNCTION - Object.toType
                  Object.toType = (function toType(global) {
                      return function (obj) {
                          if (obj === global) {
                              return "global";
                          }
                          return ({}).toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
                      }
                  })(this);

                  // FORMAT DATE TO STRING
                  function formatDate(modelDate, format) {
                      if (!modelDate) {
                          return "";
                      }
                      var date = new Date(modelDate);
                      var yyyy = date.getFullYear().toString();
                      var mm = (date.getMonth() + 1).toString();
                      var dd = date.getDate().toString();
                      switch (format) {
                          case 'mm/dd/yy':
                              return (mm[1] ? mm : "0" + mm[0]) + '/' + (dd[1] ? dd : "0" + dd[0]) + '/' + yyyy;
                              break;
                          case 'mm/dd':
                              return (mm[1] ? mm : "0" + mm[0]) + '/' + (dd[1] ? dd : "0" + dd[0]);
                              break;
                      }
                  };
                  function checkValidations(scope, ctrl) {
                      var elmDate = scope.model, validDate = false, checkMinMax = true, checkOtherValidations = true;
                      if (scope.dateRequired) {
                          if (elmDate == "") {
                              ctrl.$setValidity("required", scope.dateRequired);
                              checkOtherValidations = false;
                          }
                      } else {
                          if (elmDate == "") {
                              checkOtherValidations = false;
                          }
                      }
                      if (checkOtherValidations) {
                          if (scope.datePattern.test(elmDate)) {
                              scope.model = formatDate(new Date(elmDate), scope.config.dateFormat);
                              validDate = true;
                          }
                          if (scope.config.dateFormat.toLowerCase() == 'mm/dd') {
                              checkMinMax = false;
                          }
                          if (checkMinMax) {
                              if (validDate && new Date(scope.model) < new Date(scope.config.minDate)) {
                                  scope.dateMinDate = false;
                              } else {
                                  scope.dateMinDate = true;
                              }
                              if (validDate && new Date(scope.model) > new Date(scope.config.maxDate)) {
                                  scope.dateMaxDate = false;
                              } else {
                                  scope.dateMaxDate = true;
                              }
                              ctrl.$setValidity("minDate", scope.dateMinDate);
                              ctrl.$setValidity("maxDate", scope.dateMaxDate);
                          }
                          ctrl.$setValidity("customPattern", validDate);
                      }
                      else {
                          ctrl.$setValidity("customPattern", true);
                      }
                  };

                  return {
                      pre: function (scope, elem, attr, ctrl) {
                          // if (!ctrl) {
                          //   return;
                          // }
                          var now = new Date(),
                            defaultMinDate = new Date(now.getFullYear() - 5, now.getMonth(), now.getDate()),
                            defaultMaxDate = new Date(now.getFullYear() + 5, now.getMonth(), now.getDate());
                          var defaultConfig = {
                              firstDay: 1,
                              changeMonth: true,
                              changeYear: true,
                              dateFormat: "mm/dd/yy",
                              minDate: defaultMinDate,
                              maxDate: defaultMaxDate
                          }
                          var dateConfig = {};
                          angular.isDefined(attr.dateConfig) ? dateConfig = checkObjectAttribute(attr.dateConfig) : false;

                          // MERGE DEFAULT & CUSTOM CONFIGURATIONS
                          scope.config = angular.extend({}, defaultConfig, dateConfig || {});

                          scope.config.minDate = new Date(scope.config.minDate);
                          scope.config.maxDate = new Date(scope.config.maxDate);


                          scope.model = formatDate(scope.model, scope.config.dateFormat);
                          scope.config.onClose = function (value, picker) {
                              scope.model = value;
                          }
                          angular.isDefined(attr.dateClass) ? scope.dateClass = attr.dateClass : scope.dateClass = '';
                          angular.isDefined(attr.dateType) ? scope.dateType = attr.dateType : scope.dateType = 'text';
                          angular.isDefined(attr.dateName) ? scope.dateName = attr.dateName : scope.dateName = 'date-' + $$Utility.getUUID();
                          angular.isDefined(attr.dateLabel) ? scope.dateLabel = attr.dateLabel : scope.dateLabel = 'Date';
                          angular.isDefined(attr.dateRequired) ? scope.dateRequired = checkBooleanAttribute(attr.dateRequired) : scope.dateRequired = false;
                          angular.isDefined(attr.messageRequired) ? scope.messageRequired = attr.messageRequired : scope.messageRequired = scope.dateLabel + " is required";
                          angular.isDefined(attr.dateReadonly) ? scope.dateReadonly = checkBooleanAttribute(attr.dateReadonly) : scope.dateReadonly = false;
                          angular.isDefined(attr.dateDisabled) ? scope.dateDisabled = checkBooleanAttribute(attr.dateDisabled) : scope.dateDisabled = false;
                          angular.isDefined(attr.dateMask) ? scope.dateMask = attr.dateMask : scope.dateMask = "?99/99/9999";
                          angular.isDefined(attr.dateMaskPlaceholder) ? scope.dateMaskPlaceholder = attr.dateMaskPlaceholder : scope.dateMaskPlaceholder = "_";
                          angular.isDefined(attr.datePlaceholder) ? scope.datePlaceholder = attr.datePlaceholder : false;
                          angular.isDefined(attr.dateMaskOptions) ? scope.dateMaskOptions = attr.dateMaskOptions : scope.dateMaskOptions = "{'clearOnBlur': false}";
                          angular.isDefined(attr.datePattern) ? scope.datePattern = new RegExp(attr.datePattern) : scope.datePattern = new RegExp(/((0[13578]|1[02])[\/.]31[\/.](\d{2})[0-9]{2})|((01|0[3-9]|1[1-2])[\/.](29|30)[\/.](\d{2})[0-9]{2})|((0[1-9]|1[0-2])[\/.](0[1-9]|1[0-9]|2[0-8])[\/.](\d{2})[0-9]{2})|((02)[\/.]29[\/.](((\d{2})(04|08|[2468][048]|[13579][26]))|2000))/);
                          angular.isDefined(attr.messagePattern) ? scope.messagePattern = attr.messagePattern : scope.messagePattern = scope.dateLabel + " is not valid";
                          angular.isDefined(attr.dateCustom) ? scope.dateCustom = checkBooleanAttribute(attr.dateCustom) : scope.dateCustom = true;
                          angular.isDefined(attr.messageCustom) ? scope.messageCustom = attr.messageCustom : scope.messageCustom = scope.dateLabel + " is not valid";
                          angular.isDefined(attr.messageMinDate) ? scope.messageMinDate = attr.messageMinDate : scope.messageMinDate = scope.dateLabel + " should be after " + formatDate(scope.config.minDate, scope.config.dateFormat);
                          angular.isDefined(attr.messageMaxDate) ? scope.messageMaxDate = attr.messageMaxDate : scope.messageMaxDate = scope.dateLabel + " should be before " + formatDate(scope.config.maxDate, scope.config.dateFormat);
                          //FIRST TIME VALIDATION CHECK
                          checkValidations(scope, ctrl);
                          ctrl.$setValidity("dateCustom", scope.dateCustom);

                          attr.$observe('dateConfig', function (newValue) {
                              checkValidations(scope, ctrl);
                          });

                          attr.$observe('dateDisabled', function (newValue) {
                              if (checkBooleanAttribute(newValue) == true) {
                                  scope.dateDisabled = true;
                                  scope.dateRequired = false;
                              } else {
                                  scope.dateDisabled = false;
                                  angular.isDefined(attr.dateRequired) ? scope.dateRequired = checkBooleanAttribute(attr.dateRequired) : false;
                              }
                          });

                          attr.$observe('dateCustom', function (newValue, oldValue) {
                              if (checkBooleanAttribute(newValue) == true) {
                                  scope.dateCustom = true;
                              } else {
                                  scope.dateCustom = false;
                              }
                              ctrl.$setValidity("dateCustom", scope.dateCustom);
                          });

                          attr.$observe('dateRequired', function (newValue) {
                              if (checkBooleanAttribute(newValue) == true) {
                                  scope.dateRequired = true;
                                  scope.dateDisabled = false;
                              } else {
                                  scope.dateRequired = false;
                                  angular.isDefined(attr.dateDisabled) ? scope.dateDisabled = checkBooleanAttribute(attr.dateDisabled) : false;
                              }
                              checkValidations(scope, ctrl);
                          });

                          function checkBooleanAttribute(value) {
                              switch (Object.toType(value)) {
                                  case 'boolean':
                                      return value;
                                      break;
                                  default:
                                      value = scope.$eval(value);
                                      return value;
                              }
                          }
                          function checkObjectAttribute(value) {
                              switch (Object.toType(value)) {
                                  case 'object':
                                      return value;
                                      break;
                                  default:
                                      value = scope.$eval(value);
                                      return value;
                              }
                          }
                      },
                      post: function (scope, elem, attr, ctrl) {
                          callDatepicker(scope.config, 'start');
                          scope.customDateChange = function () {
                              checkValidations(scope, ctrl);
                          }
                          function callDatepicker(config, action) {
                              if (action == 'start') {
                                  elem.datepicker(config);
                              } else if (action == 'stop') {
                                  elem.datepicker("destroy");
                              }
                          }
                      }
                  }
              }
          }
      }]);
});

angular.module("eruditeApp.Shared.Date", [])

.directive("fzDate", ["$timeout", function($timeout) {
  return {
    restrict: "A",
    require: "?ngModel",
    link: function(scope, element, attributes) {
      scope.checkDate = function(dateString) {
        var date_regex = /^(0[1-9]|1[0-2])\/(0[1-9]|1\d|2\d|3[01])\/(19|20)\d{2}$/;
        if (!(date_regex.test(dateString))) {
          return false;
        } else {
          return true;
        }
      }
      var userConf;
      var defaultConf = {
        firstDay: 1,
        changeMonth: true,
        changeYear: true,
        dateFormat: "mm/dd/yy"
      }
      if (attributes.fzDate.length) {
        userConf = scope.$eval(attributes.fzDate);
      } else {
        userConf = {};
      }
      var config = angular.extend({}, defaultConf, userConf);
      element.datepicker(config);
      $timeout(function() {
        element.datepicker("setDate", scope.$eval(attributes.ngModel));
      });
      element.closest('body').on("click", function(e) {
        var elem = $(e.target);
        if (!elem.hasClass("hasDatepicker") &&
          !elem.hasClass("ui-datepicker") &&
          !elem.hasClass("ui-icon") &&
          !elem.hasClass("ui-datepicker-next") &&
          !elem.hasClass("ui-datepicker-prev") &&
          !$(elem).parents(".ui-datepicker").length) {
          $('.hasDatepicker').datepicker('hide');
        }
      });
    }
  }
}])

.directive("fzDateElement", ["$timeout", "$$Utility", function($timeout, $$Utility) {
  return {
    restrict: "E",
    replace: true,
    scope: {
      model: "=ngModel",
      config: "="
    },
    templateUrl: '/app/Shared/fzDate/Templates/fz-date.html',
    link: function(scope, element, attributes) {
      scope.name = $$Utility.getUUID();
      scope.label = attributes.label || Date;
      if (scope.config !== Object(scope.config)) {
        scope.config = scope.$eval(scope.config);
      }
      if (angular.isDefined(attributes.dateRequired)) {
        if (typeof attributes.dateRequired === 'boolean') {
          scope.dateRequired = attributes.dateRequired;
        } else {
          console.log("fz-date", attributes.dateRequired);
          scope.dateRequired = JSON.parse(attributes.dateRequired);
          console.log("fz-date", scope.dateRequired);
        }
      } else {
        scope.dateRequired = false;
      }
      if (angular.isDefined(attributes.readonly)) {
        scope.dateReadonly = scope.$eval(attributes.readonly);
      } else {
        scope.dateReadonly = false;
      }
      if (angular.isDefined(attributes.disabled)) {
        scope.dateDisabled = scope.$eval(attributes.disabled);
      } else {
        scope.dateDisabled = false;
      }
      var defaultConf = {
        firstDay: 1,
        changeMonth: true,
        changeYear: true,
        dateFormat: "mm/dd/yy"
      }
      var config = angular.extend({}, defaultConf, scope.config || {});

      element.find('.fz-date').datepicker(config);
      $timeout(function() {
        scope.placeholder = attributes.placeholder;
        if (scope.model) {
          var formattedDate = formatDate(scope.model);
          scope.model = formattedDate;
          element.find('.fz-date').datepicker("setDate", formattedDate)
        }
      });


      // Hide Hack
      // element.closest('body').on("click", function(e) {
      //   var elem = $(e.target);
      //   if (!elem.hasClass("hasDatepicker") &&
      //     !elem.hasClass("ui-datepicker") &&
      //     !elem.hasClass("ui-icon") &&
      //     !elem.hasClass("ui-datepicker-next") &&
      //     !elem.hasClass("ui-datepicker-prev") &&
      //     !$(elem).parents(".ui-datepicker").length) {
      //     $('.hasDatepicker').datepicker('hide');
      //   }
      // });

      // Formatting Date
      function formatDate(modelDate) {
        var date = new Date(modelDate);
        var yyyy = date.getFullYear().toString();
        var mm = (date.getMonth() + 1).toString();
        var dd = date.getDate().toString();
        return (mm[1] ? mm : "0" + mm[0]) + '/' + (dd[1] ? dd : "0" + dd[0]) + '/' + yyyy;
      };
    }
  }
}])

.directive("fzDateNoYear", ["$timeout", "$$Utility", function($timeout, $$Utility) {
  return {
    restrict: "E",
    replace: true,
    scope: {
      model: "=ngModel"
    },
    templateUrl: '/app/Shared/fzDate/Templates/fz-date-no-year.html',
    link: function(scope, element, attributes) {
      scope.name = $$Utility.getUUID();
      scope.label = attributes.label || Date;
      if (angular.isDefined(attributes.required)) {
        if (typeof attributes.required === 'boolean') {
          scope.dateRequired = attributes.required;
        } else {
          scope.dateRequired = JSON.parse(attributes.required);
        }
      } else {
        scope.dateRequired = false;
      }
      if (angular.isDefined(attributes.readonly)) {
        scope.dateReadonly = scope.$eval(attributes.readonly);
      } else {
        scope.dateReadonly = false;
      }
      if (angular.isDefined(attributes.disabled)) {
        scope.dateDisabled = scope.$eval(attributes.disabled);
      } else {
        scope.dateDisabled = false;
      }
      var defaultConf = {
        firstDay: 1,
        changeMonth: true,
        dateFormat: "mm/dd"
      }

      element.find('.fz-date').datepicker(defaultConf);
      $timeout(function() {
        scope.placeholder = attributes.placeholder;
        if (scope.model) {
          var formattedDate = formatDate(scope.model);
          scope.model = formattedDate;
          element.find('.fz-date').datepicker("setDate", formattedDate)
        }
      });

      function formatDate(modelDate) {
        var date = new Date(modelDate);
        var yyyy = date.getFullYear().toString();
        var mm = (date.getMonth() + 1).toString();
        var dd = date.getDate().toString();
        return (mm[1] ? mm : "0" + mm[0]) + '/' + (dd[1] ? dd : "0" + dd[0]) + '/' + yyyy;
      };
    }
  }
}])

.directive('dateTest', [function() {
  return {
    restrict: 'E',
    controller: function($scope) {
      $scope.date_string = 'Sat Nov 14 2015 17:15:25 GMT+0530 (India Standard Time)';
      $scope.date_timestamp = 1447501525637;
      $scope.date_formatted = '09/20/2014' //Target format
      $scope.date_date = new Date("October 13, 2014 11:13:00");


    }
  }
}])




// .directive('fzDateE', ['$$Utility', '$timeout', function($$Utility, $timeout) {
//   return {
//     restrict: 'E',
//     replace: true,
//     scope: {
//       model: "=ngModel"
//     },
//     templateUrl: '/app/Shared/fzDate/Templates/fz-date-e.html',
//     link: function(scope, elem, attr) {
//
//       // ADD GLOBAL FUNCTION - Object.toType
//       Object.toType = (function toType(global) {
//         return function(obj) {
//           if (obj === global) {
//             return "global";
//           }
//           return ({}).toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
//         }
//       })(this);
//
//       // DEFAULT CONFIG FOR DATEPICKER
//       var defaultConf = {
//         firstDay: 1,
//         changeMonth: true,
//         changeYear: true,
//         dateFormat: "mm/dd/yy"
//       }
//
//
//       var dateConfig = {};
//       angular.isDefined(attr.dateConfig) ? dateConfig = scope.$eval(attr.dateConfig) : false;
//       console.log(dateConfig);
//
//
//
//
//
//       //TYPE
//       angular.isDefined(attr.dateType) ? scope.type = attr.dateType : scope.type = 'text';
//
//       angular.isDefined(attr.dateLabel) ? scope.label = attr.dateLabel : scope.label = 'Date';
//
//       angular.isDefined(attr.dateMask) ? scope.mask = attr.dateMask : scope.mask = '99/99/9999';
//
//       angular.isDefined(attr.messageMask) ? scope.messageMask = attr.messageMask : scope.messageMask = scope.label + " is not valid";
//
//
//
//       angular.isDefined(attr.pattern) ? scope.pattern = attr.pattern : scope.pattern = "/^([0]?[1-9]|[1][0-2])[./-]([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0-9]{4}|[0-9]{2})$/";
//
//       angular.isDefined(attr.messagePattern) ? scope.messagePattern = attr.messagePattern : scope.messagePattern = scope.label + " is not valid";
//
//       angular.isDefined(attr.customFunction) ? scope.customFunction = attr.customFunction : false;
//
//       angular.isDefined(attr.messageCustomFunction) ? scope.messageCustomFunction = attr.messageCustomFunction : false;




      // FORMAT DATE TO STRING
    //   function formatDate(date, format) {
    //
    //     var date = new Date(modelDate);
    //     var yyyy = date.getFullYear().toString();
    //     var mm = (date.getMonth() + 1).toString();
    //     var dd = date.getDate().toString();
    //
    //     switch (format) {
    //       case 'mm/dd/yy':
    //         return (mm[1] ? mm : "0" + mm[0]) + '/' + (dd[1] ? dd : "0" + dd[0]) + '/' + yyyy;
    //         break;
    //       case 'mm/dd':
    //         return (mm[1] ? mm : "0" + mm[0]) + '/' + (dd[1] ? dd : "0" + dd[0]);
    //         break;
    //       default:
    //         return (mm[1] ? mm : "0" + mm[0]) + '/' + (dd[1] ? dd : "0" + dd[0]) + '/' + yyyy;
    //     }
    //   }
    // }





    // compile: function(element, attributes) {
    //   if (angular.isDefined(attributes.mask)) {
    //     element.attr('ui-mask', '99/99/9999');
    //   }
    //   if (angular.isUndefined(attributes.uiMaskPlaceholder)) {
    //     console.log("undefined ui-mask-placeholder");
    //     element.attr('ui-mask-placeholder', '');
    //   }
    //   if (angular.isUndefined(attributes.uiMaskPlaceholderChar)) {
    //     console.log("undefined ui-mask-placeholder");
    //     element.attr('ui-mask-placeholder-char', '_');
    //   }
    //
    //
    //   return {
    //     pre: function(scope, element, attributes) {
    //
    //     },
    //     post: function(scope, element, attributes) {
    //       $compile(element)(scope);
    //     }
    //   }
    // }




    //     compile: function(element, attributes) {
    //
    //       // ADD TOTYPE GLOBALLY
    //       Object.toType = (function toType(global) {
    //         return function(obj) {
    //           if (obj === global) {
    //             return "global";
    //           }
    //           return ({}).toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
    //         }
    //       })(this);
    //
    //       // SOURCE ATTRIBUTE LIST
    //       var sourceAttributeList = [];
    //       angular.forEach(attributes.$attr, function(value) {
    //         if (value != 'attributes') {
    //           sourceAttributeList.push(value)
    //         }
    //       });
    //
    //       // TEMPLATE
    //       var template = $('<input />');
    //       template.attr('type', 'text');
    //      template.attr('name', $$Utility.getUUID());
    //       template.addClass('fz-date-e');
    //
    //       // MOVE ATTRIBUTES TO DESTINATION
    //       angular.forEach(sourceAttributeList, function(value) {
    //         template.attr(value, element.attr(value));
    //       });
    //
    //       // FILL GAPS
    //       if (sourceAttributeList.indexOf('ui-mask') < 0) {
    //         template.attr('ui-mask', '99/99/9999');
    //       }
    //       if (sourceAttributeList.indexOf('ui-mask-placeholder') < 0) {
    //         template.attr('ui-mask-placeholder', '');
    //       }
    //       if (sourceAttributeList.indexOf('ui-mask-placeholder-char') < 0) {
    //         template.attr('ui-mask-placeholder-char', '_');
    //       }
    //
    //       if (sourceAttributeList.indexOf('ui-options') < 0) {
    //         if (sourceAttributeList.indexOf('placeholder') < 0) {
    //           template.attr('ui-options', '{clearOnBlur: false}')
    //         } else {
    //           template.attr('ui-options', '{clearOnBlur: true}')
    //         }
    //       }
    //
    //       // MESSAGES
    //       if (sourceAttributeList.indexOf('msg-parse') < 0) {
    //         template.attr('msg-parse', '{{label}} is not valid');
    //       }
    //       if (sourceAttributeList.indexOf('msg-required') < 0) {
    //         template.attr('msg-required', '{{label}} is required');
    //       }
    //
    // element.replaceWith(template);
    //
    //       return {
    //         post: function(scope, element, attributes, ctrl) {
    //
    //           sourceAttributeList.indexOf('label') < 0 ? scope.label = "Date" : scope.label = attributes.label;
    //           $timeout(function(){
    //             scope.$apply(function() {
    //                element.replaceWith($compile(template)(scope));
    //
    //                ui-mask={{mask}} mask="99/99"  {{attrs}}
    //                attrs='{custtomfunction:abc()}",{msg-custom-function:"hi howare you"},server-id="abc"'
    //           },200);
    //
    //
    //
    //
    //
    //
    //
    //           // // LABEL
    //           // scope.label = destinationElement.attr('label');
    //           //
    //           // // DEFAULT CONFIGURATION - DATEPICKER
    //           // var defaultConfiguration = {
    //           //   firstDay: 1,
    //           //   changeMonth: true,
    //           //   changeYear: true,
    //           //   dateFormat: "mm/dd/yy"
    //           // }
    //           //
    //           // // USER CONFIGURATION - DATEPICKER
    //           // userConfiguration = scope.$eval(destinationElement.attr('config'));
    //           //
    //           // // ALL CONFIGURATION - DATEPICKER
    //           // var configuration = angular.extend({}, defaultConfiguration, userConfiguration || {});
    //           //
    //           // // CALL DATEPICKER
    //           // // destinationElement.datepicker(configuration);
    //
    //         },
    //         // post: function() {
    //         //
    //         // }
    //       }
    //     }
//   }
// }]);

/*global angular,define*/
define(['angular', 'app/Shared/fzDropdown/Directives/fz-dropdown'], function () {
    return angular.module("eruditeApp.Shared.Dropdown", [])

    .directive('fzDropdownComponent', function () {
        return {
            restrict: "E",
            replace: true,
            scope: {
                model: '=',
                mainModel: '='
            },
            controller: ['$scope', function ($scope) {
                if (angular.isDefined($scope.model.children))
                    angular.forEach($scope.model.children, function (child) {
                        child.status = false;
                    });

            }],
            templateUrl: "/app/Shared/fzDropdown/Templates/fz-dropdown-component.html",

            //template: "<div fz-dropdown='bottom-right' <a><i class='fa fa-angle-down'> </i></a>	<div ng-if='model.children'><fz-dropdown-children ng-repeat='items in model.children' children='items'></fz-dropdown-children></div><div ng-if='!model.children'><fz-dropdown-children ng-repeat='items in model' children='items'></fz-dropdown-children></div></div>"
        }
    })

    .directive('fzDropdownChildren', function ($compile) {
        return {
            restrict: "E",
            replace: true,
            scope: {
                children: '=',
                mainModel: '='
            },
            controller: ['$scope', function ($scope) {
                //Clicked on value
                $scope.openDropDown = function (value) {
                    $scope.mainModel.count = $scope.mainModel.count || 0;
                    if ($scope.mainModel.count > 1) {

                    }
                    {
                        if (angular.isDefined($scope.mainModel.oldvalue)) {
                            $scope.mainModel.levelStatus = false;
                            angular.forEach($scope.mainModel.oldvalue.children, function (child) {
                                child.status = false;
                            })
                        }
                        angular.forEach(value.children, function (child) {
                            child.status = true;
                            value.levelStatus = true;
                        })
                        $scope.mainModel.activeHash = value.$$hashKey;
                        $scope.mainModel.oldvalue = value;
                    }
                }

                //Clicked on value
                $scope.openDropDown = function (value) {
                    var Activevalue = '';
                    if (angular.isDefined($scope.mainModel.CurrentActivePath) && $scope.mainModel.CurrentActivePath.length > 0) {
                        Activevalue = $scope.mainModel.CurrentActivePath.split(':');
                    }
                    else if (angular.isUndefined($scope.mainModel.CurrentActivePath)) {
                        Activevalue = value.menuColumT;
                    }
                    else {
                        Activevalue = $scope.mainModel.CurrentActivePath;
                    }

                    if (((Object.keys(value.menuColumT).length === Object.keys(Activevalue).length))) {
                        if (Object.keys(Activevalue).length > 1) {
                            switch (Activevalue.length) {
                                case 2: $scope.mainModel.children[Activevalue[0]].children[Activevalue[1]].children.forEach(function (c) {
                                    c.active = false;
                                    c.status = false;
                                    $scope.mainModel.children[Activevalue[0]].children[Activevalue[1]].active = false;
                                    $scope.mainModel.children[Activevalue[0]].levelStatus = false;
                                });
                                    break;

                                case 3: $scope.mainModel.children[Activevalue[0]].children[Activevalue[1]].children.forEach(function (c) {
                                    c.active = false;
                                    c.status = false;
                                    $scope.mainModel.children[Activevalue[0]].children[Activevalue[1]].children[Activevalue[2]].active = false;
                                    $scope.mainModel.children[Activevalue[0]].children[Activevalue[1]].levelStatus = false;

                                });
                                    break;
                            }
                        }
                        else if ($scope.mainModel.CurrentActivePath === value.menuColumT) {
                            $scope.mainModel.children[Activevalue].children.forEach(function (c) {
                                c.status = false;
                                c.active = false;
                            })
                            $scope.allStatus = true;
                            $scope.mainModel.children[Activevalue].children.levelStatus = false;
                        }

                    else {
                            if ($scope.mainModel.children[Activevalue].children && (angular.isUndefined($scope.allStatus) || $scope.allStatus !== true)) {
                            $scope.mainModel.children[Activevalue].children.forEach(function (c) {
                                c.status = false;
                                c.active = false;
                            })
                            $scope.mainModel.children[Activevalue].active = false;
                            // $scope.mainModel.levelStatus = false;
                        }
                        else {
                            $scope.mainModel.children[Activevalue].active = false;
                            // $scope.mainModel.levelStatus = false;
                        }
                    }
                }

                $scope.mainModel.CurrentActivePath = value.menuColumT;
                value.active = true;
                if (angular.isDefined(value.children)) {
                    value.children.levelStatus = true;
                }
                angular.forEach(value.children, function (child) {
                    child.status = true;
                    child.active = true;
                })
                value.active = true;
                //value.children.levelStatus = true;
            }


            }],
            templateUrl: "/app/Shared/fzDropdown/Templates/dropdown-component.html",
            link: function (scope, element, attrs) {
                if (angular.isDefined(scope.children) && angular.isDefined(scope.children.children) && angular.isArray(scope.children.children)) {
                        scope.children.children.currentStatus = false;
                    angular.forEach(scope.children.children, function (child) {
                        child.status = false;
                    })
                        element.append("<fz-dropdown-component main-model='mainModel'  model='children.children'></fz-dropdown-component>");
                    $compile(element.contents())(scope)
                }
            }
        }
    })

});

/*global angular,define*/
define(['angular'], function() {
    return angular.module("eruditeApp.Shared.Dropdown", [])

  .directive("fzDropdown", ['$document', '$rootScope', function($document, $rootScope) {
        return {
            restrict: "A",
            replace: true,
      compile: function(element, attributes) {
                element
                  .addClass('fz-dropdown')
                  .addClass(attributes.fzDropdown)
                  .append('<span class="fz-dropdown-arrow" />')
                  .children('*[fz-dropdown-content]')
                  .addClass('fz-dropdown-content');
                return {
          pre: function(scope, element, attributes, controllers) {

                        // This will handle document click
            var documentHandler = function(e) {
                            if (!e.target.closest('.fz-dropdown')) {
                                if (angular.isUndefined($rootScope.freezeDropdown) || !$rootScope.freezeDropdown) {
                                    $document.find('.fz-dropdown').removeClass('active');
                                }
                            }
                        };

                        // Destroy document click
            scope.$on('$destroy', function() {
                            documentHandler = null;
                        });

                        // Bind Document Click
                        $document.bind('click', documentHandler);

            element.on('click', '> a', function() {
                            if (!$(this).is('[disabled=disabled]')) {
                                if (element.hasClass('active')) {
                                    element.removeClass('active');
                                } else {
                                    $document.find('.fz-dropdown').removeClass('active');
                                    element.parents('.fz-dropdown').addClass('active');
                                    element.addClass('active');
                                }
                            }
                        });
            scope.closeDropdown = function() {
                            $document.find('.fz-dropdown').removeClass('active');
                        };
            scope.$on('closeDropdown', function(event, data) {
                            scope.closeDropdown();
                        });
                    }
                };
            }
        };
    }]);
});

/*global angular,define,console*/
define(['angular', 'app/Shared/fzDropdown/Directives/fz-dropdown'], function () {
    return angular.module("eruditeApp.Shared.NewDropdown", [])

    .directive('newDropDown', function ($compile, $document, $rootScope) {
        return {
            restrict: "E",
            replace: true,
            scope: {
                model: '='
            },
            templateUrl: "/app/Shared/fzDropdown/Templates/fz-dropdown-component.html",
            link: function (scope, elem, attr) {
                $document.bind('click', function (e) {
                    if (!e.target.closest('.fz-dropdown')) {
                        if (angular.isUndefined($rootScope.freezeDropdown) || !$rootScope.freezeDropdown) {
                            $document.find('.fz-dropdown').removeClass('active');
                        }
                    }
                });
                $('[name="dropdownContainer"]').bind("click", function () {
                    if ($(this).parent().hasClass('active')) {
                        $document.find('.fz-dropdown').removeClass('active');

                    }
                    else {
                        $(this).parent().addClass('active');
                        scope.ppppp = true;
                        console.log("scope", scope);
                    }
                });
                scope.$on('openNewDropdown', function (event, data) {
                    $document.find('.fz-dropdown').removeClass('active');
                });
                scope.$on('closeNewDropdown', function (event, data) {
                    $document.find('.fz-dropdown').removeClass('active');
                });
            }
        };
    })
    .directive('newDropDownChildren', function ($compile, $document) {
        return {
            restrict: "E",
            replace: true,
            scope: {
                child: '='
            },
            templateUrl: "/app/Shared/fzDropdown/Templates/fz-dropdown-children.html",

            link: function (scope, elem, attr) {
                scope.PositionHorizontal = scope.child.PositionHorizontal || "left";
                scope.PositionVertical = scope.child.PositionVertical || "top";
                scope.HasPermission = scope.child.HasPermission ? scope.child.HasPermission : true;
                scope.childPermission = true;
                if (angular.isDefined(scope.child.Children)) {
                    scope.child.Children.forEach(function (c) {
                        if (angular.isDefined(c.HasPermission) && c.HasPermission === false) {
                            scope.childPermission = false;
                        }
                    });
                }

                //Generate all children
                if (angular.isDefined(scope.child) && angular.isDefined(scope.child.Children)) {
                    elem.append("<div class='fz-dropdown-content' ng-show='{{childPermission}}'><ul class='dropdown-menu'><new-drop-down-children ng-repeat='subchild in child.Children' child = 'subchild'><new-drop-down-children></ul></div>");
                    $compile(elem.contents())(scope);
                }
                //click on an dropdown element
                elem.on('click', '> a', function () {
                    var isactive = false;
                    if (elem.hasClass('active')) {
                        isactive = true;
                        //elem.removeClass('active');
                    }
                    $document.find('.fz-dropdown').removeClass('active');
                    elem.parents('.fz-dropdown').addClass('active');
                    if (isactive) {
                        elem.removeClass('active');

                    } else {
                        elem.addClass('active');
                    }
                    if (elem.children('div').length == 0) {
                        $document.find('.fz-dropdown').removeClass('active');
                    }
                    $document.find('[name="dropdownContainer"]').removeClass('active');
                });

                scope.closeDropdown = function () {
                    scope.$emit("closeNewDropdown");
                };
            }
        };
    });
});



define(['angular',
    'app/Shared/Services/utility.service',
], function () {

    return angular.module("eruditeApp.Shared.File", ['eruditeApp.Shared.UtilityService'])

.directive("fzFile", ['$$Utility', function($$Utility) {
  return {
    restrict: "E",
    replace: true,
    scope: {
      model: '=ngModel'
    },
    templateUrl: '/app/Shared/fzFile/Templates/fz-file.html',
    link: function(scope, element, attributes) {
      var fileInput = element.find('.fz-file-input');
      var clickable = element.find('.fz-file-display')
      scope.filePlaceholder = attributes.placeholder || "Choose File";
      scope.buttonText = attributes.button || "Browse";
      scope.fileName = "";
      scope.fileLength = 0;
      scope.name = $$Utility.getUUID();
      scope.required = false;
      scope.readonly = false;
      scope.multiple = false;
      scope.maxSize = attributes.maxSize || "5MB";
      scope.label = attributes.label || "Upload File";
      scope.msgMaxSize = attributes.msgMaxSize || scope.label + " should be less than 5 MB";
      if (angular.isDefined(attributes.required)) {
        scope.required = true;
        scope.msgRequired = attributes.msgRequired || scope.label+ " is Mndatory" ;
      }
      if (angular.isDefined(attributes.readonly)) {
        fileInput.attr('readonly', 'readonly');
        scope.readonly = true;
      }
      if (angular.isDefined(attributes.multiple)) {
        fileInput.attr('multiple', 'multiple');
        scope.multiple = true;
      }
      if (angular.isDefined(attributes.filesize)) {
        scope.filesize = attributes.filesize;
      }
      angular.element(clickable).on('click', function() {
        $(this).next('.fz-file-input').trigger('click');
      });
      angular.element(fileInput).on('change', function(evt) {
        var filenamearray = [];
        if (scope.multiple) {
          scope.model = [];
        }
        var file = $(evt.currentTarget).get(0).files;
        var isFileValid = true;
        angular.forEach(file, function(value, key) {
          filenamearray.push(value.name);
          if (!scope.multiple) {
            scope.model = value;
          } else {
            scope.model.push(value);
          }
        });
        scope.$apply(function() {
          if (file) {
            scope.fileName = filenamearray.join(", ");
            scope.fileLength = file.length;
          }
        });
      })
      scope.CheckforError = function() {
        return angular.element(fileInput).hasClass('has-error');
      }
      scope.$watch('model', function() {
        if (scope.model == null) {
          scope.fileName = "";
          scope.fileLength = 0;
          angular.element(fileInput).val('');
        }
      });
    }
  }
}])

.directive("fileSizeValidator", [function() {
  return {
    restrict: "A",
    require: 'ngModel',
    link: function(scope, element, attributes, ctrl) {
      ctrl.$validators.fileSizeValidator = function(modelValue, viewValue) {
        var isFileValid = true;
        if (!scope.multiple) {
          if (modelValue && modelValue.size > scope.translateScalars(scope.maxSize)) {
            isFileValid = false;
          }
        } else {
          angular.forEach(modelValue, function(value, key) {
            if (value.size > scope.translateScalars(scope.maxSize)) {
              isFileValid = false;
              return;
            }
          });
        }
        return isFileValid;
      };
      attributes.$observe('fileSizeValidator', function() {
        ctrl.$validate();
      });
      scope.translateScalars = function(str) {
        if (angular.isString(str)) {
          if (str.search(/kb/i) === str.length - 2) {
            return parseFloat(str.substring(0, str.length - 2) * 1000);
          } else if (str.search(/mb/i) === str.length - 2) {
            return parseFloat(str.substring(0, str.length - 2) * 1000000);
          } else if (str.search(/gb/i) === str.length - 2) {
            return parseFloat(str.substring(0, str.length - 2) * 1000000000);
          } else if (str.search(/b/i) === str.length - 1) {
            return parseFloat(str.substring(0, str.length - 1));
          } else if (str.search(/s/i) === str.length - 1) {
            return parseFloat(str.substring(0, str.length - 1));
          } else if (str.search(/m/i) === str.length - 1) {
            return parseFloat(str.substring(0, str.length - 1) * 60);
          } else if (str.search(/h/i) === str.length - 1) {
            return parseFloat(str.substring(0, str.length - 1) * 3600);
          }
        }
        return str;
      };
    }
  }
}]);
});

define(['angular'], function () {
    return angular.module("eruditeApp.Shared.Grid", [])
  .directive("fzGrid", ['$timeout', '$compile', 'GRID_PAGE_SIZE', function ($timeout, $compile, GRID_PAGE_SIZE) {
      return {
          restrict: "E",
          scope: {
              model: '=',
              ongridload: '&',
              onrowclick: '&',
              onradiobtnclick: '&',
              onfilter: '&',
              oncommand: '&',
              onaction: '&',
              onlinkclick: '&'
          },
          controller: ['$scope', '$element', 'filterFilter', function ($scope, $element, filterFilter) {
              if (angular.isDefined($scope.model)&& angular.isUndefined($scope.model.actionPermission)) {
                  $scope.model.actionPermission = true;
              }
              if (angular.isDefined($scope.model) && angular.isUndefined($scope.model.infiniteScroll)) {
                  $scope.model.infiniteScroll = false;
              }

              if (angular.isDefined($scope.model) && !$scope.model.PageSize) {
                  $scope.model.PageSize = GRID_PAGE_SIZE;
              }

              this.setColumns = function (cols) {
                  $scope.model.cols = cols;
              };

              this.setSelect = function (select) {
                  if ($scope.model.actionPermission) {
                      $scope.gridrowselection = true;
                      $scope.model.cols.unshift({
                          title: "Select",
                          field: "selectionFeature",
                          filter: false,
                          disable: false,
                          permission: true
                      });
                  }
              };


              this.setRadioBtn = function (select) {
                  if ($scope.model.actionPermission) {
                      $scope.gridrowradiobtn = true;
                      $scope.model.cols.unshift({
                          title: "Select",
                          field: "radioBtnFeature",
                          filter: false,
                          disable: false,
                          permission: true
                      });
                  }
              };
              this.setActions = function (actions) {
                  $scope.actions = actions;
              }

              this.updatepagination = function () {
                  $scope.model.pagination = true;
              };
              $scope.$watch('model.colArray', function () {
                  angular.forEach($scope.model.cols, function (value) {
                      if (value.field != "Delete" && value.field != "selectionFeature" && angular.isDefined($scope.model.colArray) && $scope.model.colArray.indexOf(value.field) < 0) {
                          value.disable = true;
                      } else {
                          value.disable = false;
                      }
                  });
              })
              $scope.$watch('model.data', function () {
                  angular.forEach($scope.model.data, function (value, key) {
                      if (!("disableSelection" in value)) {
                          value.disableSelection = false;
                      }
                  });
                  $scope.updatePagination();
                  $scope.allRowsCount = filterFilter($scope.model.data, {
                      "disableSelection": false
                  }).length;
                  $scope.selectedRowsFunc();
              })
              $scope.gridLoad = function (isInfiniteScroll) {
                  if (isInfiniteScroll) {
                      $scope.ongridload({ isinfinitescroll: true });
                  } else {
                      $scope.ongridload();
                  }
              }
              $scope.rowClick = function (row) {
                  $scope.onrowclick({
                      row: row
                  });
              }
              $scope.radioButtonClick = function (row) {
                  $scope.onradiobtnclick({
                      row: row
                  });
              }


              $scope.filterClick = function (filter) {
                  $scope.model.PageIndex = 1;
                  $scope.onfilter({
                      filter: filter
                  })
              }
              $scope.commandClick = function (command) {
                  $scope.oncommand({
                      command: command
                  })
              }
              $scope.actionClick = function (action) {
                  if ($scope.model.selectedRowsCount > 0) {
                      $scope.onaction({
                          action: action
                      })
                  }
              }
              $scope.model.gridPrevDisabled = true;
              $scope.model.gridNextDisabled = true;
              $scope.updatePagination = function () {
                  if ($scope.model.PageIndex == 1) {
                      $scope.model.gridPrevDisabled = true;
                      $scope.model.gridFromRecord = 1;
                      if ($scope.model.PageSize >= $scope.model.gridTotalRecords) {
                          $scope.model.gridNextDisabled = true;
                          $scope.model.gridToRecord = $scope.model.gridTotalRecords;
                      } else {
                          $scope.model.gridNextDisabled = false;
                          $scope.model.gridToRecord = $scope.model.PageSize;
                      }
                  } else if ($scope.model.PageIndex > 1) {
                      $scope.model.gridPrevDisabled = false;
                      $scope.model.gridFromRecord = ($scope.model.PageSize * ($scope.model.PageIndex - 1)) + 1;
                      if ($scope.model.PageSize * $scope.model.PageIndex >= $scope.model.gridTotalRecords) {
                          $scope.model.gridNextDisabled = true;
                          $scope.model.gridToRecord = $scope.model.gridTotalRecords;
                      } else {
                          $scope.model.gridNextDisabled = false;
                          $scope.model.gridToRecord = $scope.model.PageSize * $scope.model.PageIndex;
                      }
                  }
              }
              $scope.nextPage = function () {
                  if (!$scope.model.gridNextDisabled) {
                      $scope.model.PageIndex++;
                      $scope.gridLoad();

                  }
              }
              $scope.prevPage = function () {
                  if (!$scope.model.gridPrevDisabled) {
                      $scope.model.PageIndex--;
                      if ($scope.model.gridToRecord != $scope.model.gridTotalRecords) {
                          $scope.model.gridToRecord = $scope.model.gridToRecord - ($scope.model.PageSize * 2);
                      }
                      $scope.gridLoad();
                  }
              }
              $scope.filterChange = function () {
                  for (var k in $scope.model.filters) {
                      if ($scope.model.filters[k] == "") {
                          delete $scope.model.filters[k];
                      }
                  }

                  $scope.$emit('filterChanged');
                  if ($scope.model.PageIndex > 1) {
                      $scope.model.PageIndex = 1;
                      $scope.gridLoad();
                  } else {
                      $scope.gridLoad();
                  }
              }
              $scope.selectedRowsFunc = function () {
                  var selectedRows = $scope.model.data.filter(function (select) {
                      return select.selected;
                  });
                  $scope.model.selectedRowsCount = selectedRows.length || 0;
              };
              $scope.selectedRowsFunc();
              $scope.rowCheckboxClickFunction = function (row) {
                  $scope.selectedRowsFunc();
              }
              $scope.selectAll = function () {
                  if ($scope.allRowsCount > $scope.model.selectedRowsCount) {
                      angular.forEach(filterFilter($scope.model.data, {
                          "disableSelection": false
                      }), function (value, key) {
                          value.selected = true;
                      });
                  } else if ($scope.allRowsCount == $scope.model.selectedRowsCount) {
                      angular.forEach(filterFilter($scope.model.data, {
                          "disableSelection": false
                      }), function (value, key) {
                          value.selected = false;
                      });
                  }
                  $scope.selectedRowsFunc();
              }

              $scope.infiniteUpdate = function () {
                  $scope.gridLoad(true);
              }

              $scope.execlinkClick = function (colname, row) {
                  $scope.onlinkclick({
                      colname: colname,
                      row: row
                  });
              };

          }],
          link: function (scope, element, attributes) {
              var dynamicGrid = $compile("<dynamic-grid />")(scope);
              element.append(dynamicGrid);
              scope.ongridload();
          }
      }
  }])
  .directive("gridTitle", function () {
      return {
          restrict: "E",
          link: function (scope, element, attributes) {
              if (attributes.value.length) {
                  scope.model.title = attributes.value;
              }
          }
      }
  })
  .directive("gridPagination", function () {
      return {
          restrict: "E",
          require: "^fzGrid",
          link: function (scope, element, attributes, controller) {
              controller.updatepagination();
          }
      }
  })
  .directive("gridActions", function () {
      return {
          restrict: "E",
          template: "",
          require: "^fzGrid",
          compile: function (element, attributes) {
              var template = element.html();
              element.empty();
              return {
                  pre: function (scope, element, attributes, controllers) {
                      controllers.setActions(template);
                  }
              }
          }
      }
  })
  .directive("grid", function () {
      return {
          restrict: "E",
          require: ["^fzGrid", "grid"],
          controller: function () {
              var columns = [];
              this.addColumn = function (col) {
                  columns.push(col);
              };
              this.getColumns = function () {
                  return columns;
              };
          },
          link: function (scope, element, attributes, controllers) {
              var fzGridController = controllers[0];
              var gridColumnsController = controllers[1];
              fzGridController.setColumns(gridColumnsController.getColumns());
          }
      }
  })
  .directive("gridColumn", function () {
      return {
          restrict: "E",
          require: "^grid",
          link: {
              pre: function (scope, element, attributes, gridController) {

                  gridController.addColumn({
                      title: attributes.title || "Grid Title",
                      field: attributes.field || "gridfield",
                      filter: scope.$eval(attributes.filter) || false,
                      disable: scope.$eval(attributes.disable) || false,
                      permission: (attributes.permission == "false") ? false : true
                  });
              }
          }
      }
  })
  .directive("gridRowSelection", function () {
      return {
          restrict: 'E',
          require: '^fzGrid',
          link: function (scope, element, attributes, fzGridController) {
              fzGridController.setSelect();
          }
      };
  })

  .directive("gridRowRadioButton", function () {
      return {
          restrict: 'E',
          require: '^fzGrid',
          link: function (scope, element, attributes, fzGridController) {
              fzGridController.setRadioBtn();
          }
      };
  })




  .directive("dynamicGrid", ['$compile', function ($compile) {
      return {
          restrict: "E",
          templateUrl: "/app/Shared/fzGrid/Templates/fz-grid.html",
          link: function (scope, element, attributes, controller) {
              var actions = $compile(scope.actions)(scope);
              element.find(".fz-action").append(actions);
          }
      }
  }])
  .directive("dropdownFilter", function () {
      return {
          restrict: 'E',
          replace: true,
          transclude: true,
          templateUrl: '/app/Shared/fzGrid/Templates/fz-dropdown-filter.html'
      }
  })
  .directive("dropdownFilterOption", function () {
      return {
          restrict: 'E',
          scope: true,
          replace: true,
          transclude: true,
          template: '<li><a ng-click="closeDropdown(); filterClick(value)">{{title}}</a></li>',
          link: function (scope, element, attributes) {
              scope.title = attributes.title;
              scope.value = attributes.value;
              scope.closeDropdown = function () {
                  scope.$emit('closeDropdown');
              }
          }
      }
  })
  .directive("dropdownAction", function () {
      return {
          restrict: 'E',
          replace: true,
          transclude: true,
          templateUrl: '/app/Shared/fzGrid/Templates/fz-dropdown-action.html',
          link: function (scope, element, attributes) {
              scope.fzUiTrim = attributes.uiTrim;
          }
      }
  })
  .directive("dropdownActionOption", function () {
      return {
          restrict: 'E',
          scope: true,
          replace: true,
          transclude: true,
          template: '<li><a ng-click="closeDropdown(); actionClick(value)" ng-class="!model.selectedRowsCount > 0 ? \'disabled\': \'\'"  fz-ui-trim=\'{{fzUiTrim}}\'>{{title}}</a></li>',
          link: function (scope, element, attributes) {
              scope.title = attributes.title;
              scope.value = attributes.value;
              scope.fzUiTrim = attributes.uiTrim;
              scope.closeDropdown = function () {
                  scope.$emit('closeDropdown');
              }
          }
      }
  });
});

/// <reference path="../../Directives/FzNumber.js" />
/*global angular*/

define(['angular',
'app/Shared/Services/utility.service.js',
'angular-ui-mask',
'app/Shared/Directives/FzNumber'], function () {
    return angular.module('eruditeApp.Shared.PhoneDirective', [])
    .directive('fzPhone', ['$$Utility', function ($$Utility) {
        var phoneController = ['$scope', '$timeout', function ($scope, $timeout) {
            $scope.label = "Phone";
            $scope.name = $$Utility.getUUID();
            $scope.$watch('model', function (value) {
                if (value) {
                    var val = angular.copy($scope.model);
                    val = val.split(' x');
                    $scope.phone = val[0];
                    $scope.phoneExt = val[1];
                }
            });
            $scope.$watch('phone', function (value) {
                if ($scope.phoneExt && value) {
                    $scope.model = value + " x" + $scope.phoneExt;
                }
                else {
                    $scope.model = $scope.phone;
                }
            });
            $scope.$watch('phoneExt', function (value) {
                if (value && $scope.phone) {
                    $scope.model = $scope.phone + " x" + value;
                }
                else {
                    $scope.model = $scope.phone;
                }
            });
        }];

        return {
            restrict: 'E',
            replace: true,
            templateUrl: '/app/Shared/fzPhone/Templates/fz-phone.html',
            scope: {
                model: '=',
            },

            controller: phoneController,

            link: function (scope, element, attrs, ctrl) {
                if (angular.isDefined(attrs.label)) {
                    scope.label = attrs.label;
                }

                if (angular.isUndefined(attrs.required)) {
                    scope.required = false;
                }
                else {
                    scope.required = true;
                }

                if (angular.isUndefined(attrs.readonly)) {
                    scope.readonly = false;
                }
                else {
                    scope.readonly = true;
                }

                scope.PopulatePhoneWithExtn = function () {
                    if (scope.phoneExt && scope.phone) {
                        scope.model = scope.phone + " x" + scope.phoneExt;
                    }
                    else {
                        scope.model = scope.phone;
                    }
                };
            }
        };
    }]);
});

define(['angular'], function () {
    return angular.module("eruditeApp.Shared.Inbox", [])

.directive("fzInbox", function () {
    return {
        restrict: "E",
        replace: true,
        transclude: true,
        scope: {
            model: "=",
            update: "&"
        },
        templateUrl: "/app/Shared/fzInbox/Templates/fz-inbox.html",
        controller: function ($scope, $http) {
            $scope.inboxUpdate = function () {
                $scope.model.startindex = $scope.model.data.length + 1;
                $scope.update();
            }
            $scope.inboxResetUpdate = function () {
                $scope.model.data = [];
                $scope.model.startindex = 1;
                $scope.update();
            }
            $scope.inboxSortClick = function(option){
              if ($scope.model.sort.sortValue == option.value){
                $scope.model.sort.sortOrder = !$scope.model.sort.sortOrder;
              }
              $scope.model.sort.sortValue = option.value;
              $scope.inboxResetUpdate();
            };
        }
    }
})
  .directive("fzScrollAction", function () {
      return {
          restrict: "A",
          link: function (scope, element, attributes) {
              var raw = element[0];
              element.bind('scroll', function () {
                  if (raw.scrollTop + raw.offsetHeight >= raw.scrollHeight - 10) {
                      scope.$apply(attributes.fzScrollAction);
                  }
              });
          }
      }
  });
});

// angular.module("eruditeApp.Shared.Scheduler", [])

// .directive("fzScheduler", function($window, $document, $timeout) {
//   return {
//     restrict: "A",

//     link: function(scope, element, attributes) {

//       var fzWindow = angular.element($window),
//         fzDocument = angular.element($document);

//       element.addClass('show');

//       scope.mode = "day";


//       scope.fzsStyles = {
//         width: 0,
//         height: 0
//       }
//       scope.fzsHeaderStyles = {
//         width: 0,
//         height: 0,
//         top: 0,
//         left: 0
//       }
//       scope.fzsTimeslotStyles = {
//         width: 0,
//         height: 0,
//         top: 0,
//         left: 0
//       }
//       scope.fzsContentStyles = {
//         width: 0,
//         height: 0,
//         top: 0,
//         left: 0
//       }


//       var set_fzsWidth = function() {


//         scope.$apply(function() {
//           scope.fzsStyles.width = fzWindow.width() - element.offset().left - 15
//         });
//       }
//       var set_fzsHeight = function() {
//         var footerHeight;
//         if (fzWindow.height() <= fzDocument.find('.fz-footer').offset().top) {
//           footerHeight = 15;
//         } else {
//           footerHeight = (fzWindow.height() - fzDocument.find('.fz-footer').offset().top) + 15;
//         }
//         scope.$apply(function() {
//           scope.fzsStyles.height = fzWindow.height() - element.offset().top - footerHeight;
//         });
//       }

//       fzWindow.on("resize", function() {
//         set_fzsWidth()
//         set_fzsHeight();
//       });
//       element.closest(".fz-wrapper").on("scroll", function() {
//         // element.scrollTop - is the pixels hidden in top due to the scroll.With no scroll its value is 0.
//         // element.scrollHeight - is the pixels of the whole div.
//         // element.clientHeight - is the pixels that you see in your browser.
//         set_fzsWidth()
//         set_fzsHeight();
//       })
//     }
//   }
// });


define(["angular",
    'app/Shared/Services/lookup-service'], function () {
        'use strict';
        return angular.module("eruditeApp.Shared.Select", [])

         .directive("fzSelectPatient", ['$$Lookup', function ($$Lookup) {
             return {
                 restrict: "E",
                 controller: function ($scope, $element) {
                     $scope.params = {
                         "Offset": 15,
                         "StartIndex": 1,
                         "Filter": ""
                     }
                     $scope.selectModel = [];
                     $scope.appendSelectData = function () {
                         (function (params) {
                             $$Lookup.getPatientsInfinite(params)
                               .success(function (response) {
                                   $scope.selectModel = $scope.selectModel.concat(response);
                               })
                               .error(function (error) { });
                         })($scope.params);
                     }
                     $scope.getSelectData = function () {
                         (function (params) {
                             $$Lookup.getPatientsInfinite(params)
                               .success(function (response) {
                                   var empty = [{ 'PatientID': null, 'PatientName': 'Select' }];
                                   $scope.selectModel = empty.concat(response);
                               })
                               .error(function (error) { });
                         })($scope.params);
                     }
                 }
             }
         }])
            .directive("fzSelectPayor", ['$$Lookup', function ($$Lookup) {
                return {
                    restrict: "E",
                    controller: function ($scope, $element) {
                        $scope.params = {
                            "Offset": 15,
                            "StartIndex": 1,
                            "Filter": ""
                        }
                        $scope.selectModel = [];
                        $scope.appendSelectData = function () {
                            (function (params) {
                                $$Lookup.getPayors(params)
                                  .success(function (response) {
                                      $scope.selectModel = $scope.selectModel.concat(response);
                                  })
                                  .error(function (error) { });
                            })($scope.params);
                        }
                        $scope.getSelectData = function () {
                            (function (params) {
                                $$Lookup.getPayors(params)
                                  .success(function (response) {
                                      var empty = [];
                                      $scope.selectModel = empty.concat(response);
                                  })
                                  .error(function (error) { });
                            })($scope.params);
                        }
                    }
                }
            }])
         .directive("fzSelect", [function () {
             return {
                 restrict: "E",
                 scope:
                     {
                         params: '=',
                         selectModel: '=',
                         getSelectData: '&',
                         appendSelectData: '&',
                     },
                 link: function (scope, element, attributes, controller) {
                     if (angular.isUndefined(attributes.params)) {
                         scope.params = {
                             "Offset": 15,
                             "StartIndex": 1,
                             "Filter": ""
                         }
                     }
                     scope.getSelectData();
                     scope.refreshModel = function (filter) {
                         if (filter.length > 2) {
                             scope.params.StartIndex = 1;
                             scope.params.Filter = filter;
                             scope.getSelectData();
                         } else {
                             scope.params.StartIndex = 1;
                             scope.params.Filter = "";
                             scope.getSelectData();
                         }
                     }
                     var elem = angular.element(element.find('.ui-select-choices'));
                     elem.bind('scroll', function () {
                         if (elem[0].scrollTop + elem[0].offsetHeight >= elem[0].scrollHeight - 10) {
                             scope.params.StartIndex++;
                             scope.appendSelectData();
                         }
                     });
                 }
             }
         }]);

    });
/*global console,angular*/
define(["angular",
    'app/eruditeconfig',
    'toaster',
    'app/Shared/fzSnapshot/fzPayorSnapshot/fz-payor-snapshot-service'], function () {
        'use strict';
        var fzPayorSnapshotController = ['$scope', '$$PayorSnapshot', '$state', '$timeout', 'toaster',
        function ($scope, $$PayorSnapshot, $state, $timeout, toaster) {
            $scope.tab = {};
            $scope.tab.active = "PLAN";
            $scope.getPayorSnapshotDetails = function (payorID) {
                $scope.tab.active = "PLAN";
                $$PayorSnapshot.getPayorSnapshotDetails(payorID)
                    .success(function (resp) {
                        $scope.PayorSnapshot = resp;
                        console.log('PayorSnapshot', resp);
                    }).error(function (error) {
                        toaster.error("Something went wrong");
                    });
            };


        }];
        return angular.module('eruditeApp.Shared.PayorSnapshotController', ['eruditeApp.Shared.PayorSnapshotService'])
            .controller('fzPayorSnapshotController', fzPayorSnapshotController)
            .directive('fzPayorSnapshot', ['$timeout', function ($timeout) {
                return {
                    restrict: 'E',
                    replace: true,
                    templateUrl: 'app/Shared/fzSnapshot/fzPayorSnapshot/fz-payor-snapshot.html',
                    scope: {
                        value: '=',
                        id:'='
                    },

                    controller: 'fzPayorSnapshotController',
                    //link: {
                    //    pre: function (scope, element, attributes) {
                    //        scope.value = attributes.value;
                    //        scope.ID = attributes.id;

                    //    }
                    //}
                };

            }]);
    });

/*global angular*/
//(function (angular, undefined) {
define(['angular',
    'app/eruditeconfig'

], function () {
    'use strict';
    return angular.module('eruditeApp.Shared.PayorSnapshotService', [])
      .service('$$PayorSnapshot', ['$q', '$http', 'ERUDITE_CONFIG', function ($q, $http, ERUDITE_CONFIG) {
          var apiUrl = ERUDITE_CONFIG.baseUrl;
          this.getPayorSnapshotDetails = function (payorID) {
              var deferred = $q.defer(),
                  promise = deferred.promise;
              $http.get(apiUrl + 'setup/payor/get-payor-snapshot/' + payorID)
                               .then(function (resp) {
                                   deferred.resolve(new PayorSnapshot(resp.data));
                               })
                               .catch(function (error) {
                                   deferred.reject(error.data);
                               });
              promise.success = function (callback) {
                  promise.then(callback);
                  return promise;
              };
              promise.error = function (callback) {
                  promise.catch(callback);
                  return promise;
              };
              return promise;
          };
      }]);
    function PayorSnapshot(payorSnapshot) {
        var p = payorSnapshot || {};
        this.Plan = new PlanModel(p.Plan);
        this.Payor = new ClaimPayorModel(p.Payor);
        this.Benefits = new BenefitModel(p.Benefits);
        this.Notes = new InsuranceNoteModel(p.Notes);
        this.Heading = new PayorSnapShotHeadingModel(p.Heading);

    };
    function PlanModel(plan) {
        var p = plan || {};
        this.PlanName = p.PlanName || "";
        this.CapitationFee = p.CapitationFee || "";
        this.EmployerName = p.EmployerName || "";
    };
    function ClaimPayorModel(claim) {
        var p = claim || {};
        this.PayorID = p.PayorID || "";
        this.Address = new Address(p.Address);
        this.Website = p.Website || "";
    };
    function BenefitModel(benefit) {
        var p = benefit || {};
        this.FamilyMaximum = p.FamilyMaximum || "";
        this.IndividualMaximum = p.IndividualMaximum || "";
        this.FamilyDeductible = p.FamilyDeductible || "";
        this.IndividualOrthoMaximum = p.IndividualOrthoMaximum || "";
        this.IndividualOrthoDeductible = p.IndividualOrthoDeductible || "";
        this.IndividualOrthoAgeLimit = p.IndividualOrthoAgeLimit || "";

    }
    function InsuranceNoteModel(insurance) {
        var p = insurance || {};
        this.Notes = p.Notes || "";       
    }
    function Address(addr) {
        var a = addr || {};
        this.AddressDetailID = a.AddressDetailID || 0;
        this.AddressLine1 = a.AddressLine1 || "";
        this.AddressLine2 = a.AddressLine2 || "";
        this.City = a.City || "";
        this.State = a.State || "";
        this.ZipCode = a.ZipCode || "";
    }
    function PayorSnapShotHeadingModel(payor) {
        var a = payor || {};
        this.PayorName = a.PayorName || "";
        this.PlanType = a.PlanType || "";
    }
});
/*global console,angular*/
define(["angular",
    'app/eruditeconfig',
    'toaster',
    'app/Shared/fzSnapshot/fzProviderSnapshot/fz-provider-snapshot-service'], function () {
        'use strict';
        var fzProviderSnapshotController = ['$scope', '$$ProviderSnapshot', '$state', '$timeout', 'toaster',
        function ($scope, $$ProviderSnapshot, $state, $timeout, toaster) {
            $scope.tab = {};
            $scope.tab.active = "PROFILE";
            $scope.getProviderSnapshotDetails = function (providerID) {
                $scope.tab.active = "PROFILE";
                $$ProviderSnapshot.getProviderSnapshotDetails(providerID)
                    .success(function (resp) {
                        $scope.ProviderSnapshot = resp;
                        console.log('ProviderSnapshot', resp);
                    }).error(function (error) {
                        toaster.error("Something went wrong");
                    });
            };


        }];
        return angular.module('eruditeApp.Shared.ProviderSnapshotController', ['eruditeApp.Shared.ProviderSnapshotService'])
            .controller('fzProviderSnapshotController', fzProviderSnapshotController)
            .directive('fzProviderSnapshot', ['$timeout', function ($timeout) {
                return {
                    restrict: 'E',
                    replace: true,
                    templateUrl: 'app/Shared/fzSnapshot/fzProviderSnapshot/fz-provider-snapshot.html',
                    scope: {
                        value: '=',
                        id: '='
                    },
                    controller: 'fzProviderSnapshotController',
                    //link: {
                    //    pre: function (scope, element, attributes) {
                    //        scope.value = attributes.value;
                    //        scope.ID = attributes.id;

                    //    }
                    //}
                };

            }]);
    });

/*global angular*/
//(function (angular, undefined) {
define(['angular',
    'app/eruditeconfig'

], function () {
    'use strict';
    return angular.module('eruditeApp.Shared.ProviderSnapshotService', [])
      .service('$$ProviderSnapshot', ['$q', '$http', 'ERUDITE_CONFIG', function ($q, $http, ERUDITE_CONFIG) {
          var apiUrl = ERUDITE_CONFIG.baseUrl;         
          this.getProviderSnapshotDetails = function (providerID) {
              var deferred = $q.defer(),
                  promise = deferred.promise;
              $http.get(apiUrl + 'user/provider-snapshot/' + providerID)
                               .then(function (resp) {                                                                
                                   deferred.resolve( new ProviderSnapshot(resp.data));
                               })
                               .catch(function (error) {
                                   deferred.reject(error.data);
                               });
              promise.success = function (callback) {
                  promise.then(callback);
                  return promise;
              };
              promise.error = function (callback) {
                  promise.catch(callback);
                  return promise;
              };
              return promise;
          };
      }]);
    function ProviderSnapshot(providerSnapshot) {
        var p = providerSnapshot || {};
        this.ProviderProfile = new ProviderProfile(p.ProviderProfile);
        this.ProductionModel = new ProductionModel(p.Payor);
        this.AppointmentsModel = new AppointmentsModel(p.AppointmentsModel);

    };
    function ProviderProfile(providerProfile) {
        var p = providerProfile || {};
        this.ProviderID = p.ProviderID || "";
        this.Speciality = p.Speciality || "";
        this.ProviderName = p.ProviderName || "";
        this.LinkedLocations = p.LinkedLocations || "";
        this.LinkedPatients = p.LinkedPatients || "";
        this.Phone1 = p.Phone1 || "";
        this.Phone2 = p.Phone2 || "";
        this.Email = p.Email || "";
    };
    function ProductionModel(providerProfile) {
        var p = providerProfile || {};
        this.Surgery = p.Surgery || "";
        this.General = p.General || "";
        this.Emergency = p.Emergency || "";
        this.Unplanned = p.Unplanned || "";
    };
    function AppointmentsModel(providerProfile) {
        var p = providerProfile || {};
        this.TotalAppointmentsToday = p.TotalAppointmentsToday || "";
        this.AvailableTimeToday = p.AvailableTimeToday || "";
        this.Loc = p.Loc;
    };
});
define(['angular', 'xtForm'], function () {
    return angular.module('eruditeApp.Shared.FormSubmitDirective', [])
    .directive('fzSubmit', ['$parse', function ($parse) {

        return {
            restrict: 'E',
            require: ['^?form', '^?xtForm'],
            replace: true,
            templateUrl: '/app/Shared/fzSubmit/Templates/fz-submit.html',
            link: function (scope, elm, attrs, ctrl) {
                var form = ctrl[0];
                var xtform = ctrl[1];
                var fn;

                scope.cssClass = attrs.classList || "fz-button fz-button-blue";

                scope.$watch('isLoading', function (newValue, oldValue) {
                    if (newValue) {
                        $(elm).prop('disabled', true)
                    }
                    else
                    {
                        $(elm).prop('disabled', false)
                    }

                })

                elm.bind("click keydown", function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    scope.$apply(function () {
                        var keycode = event.keyCode;
                        if (angular.isUndefined(keycode) || keycode == 13) {
                            xtform.submit().then(function () {
                                if (form.$valid) {

                                    if (fn) {
                                        fn(scope, { $event: event });
                                    }
                                }
                            }, function () {

                            });
                        }
                    });
                });

                if (angular.isDefined(attrs.function)) {
                    fn = $parse(attrs['function']);
                }
            }
        };
    }]);
});

define(['angular',
], function () {

return angular.module("eruditeApp.Shared.Utilities", [])

.directive("fzScrollAction", function() {
    return {
      restrict: "A",
      link: function(scope, element, attributes) {
        var raw = element[0];
        element.bind('scroll', function() {
          if (raw.scrollTop + raw.offsetHeight >= raw.scrollHeight - 10) {
            scope.$apply(attributes.fzScrollAction);
          }
        });
      }
    }
  })
  .directive('indeterminateCheckbox', function() {
    return {
      restrict: 'A',
      link: function(scope, element, attributes) {
        return scope.$watch(attributes.indeterminateCheckbox, function(val) {
          return element.prop('indeterminate', !!val);
        });
      }
    };
  });
});

/*global angular,console,state*/
define(["angular",
    'app/eruditeconfig',
 'app/User/Student/Shared/student-model'], function () {
     'use strict';
     return angular.module('eruditeApp.Student.AttendanceService', ['ngEnter'])
        .service('$$Attendance', ['$q', '$http', 'ERUDITE_CONFIG', function ($q, $http, ERUDITE_CONFIG) {
            var apiUrl = ERUDITE_CONFIG.baseUrl;
            this.getAllStudents = function (gridRequest) {
                var deferred = $q.defer(),
                  promise = deferred.promise;

                $http.post(apiUrl + 'student/get-all', gridRequest)
                .then(function (resp) {
                    deferred.resolve(resp.data);
                })
                .catch(function (error) {
                    deferred.reject(error.data);
                });
                promise.success = function (callback) {
                    promise.then(callback);
                    return promise;
                };
                promise.error = function (callback) {
                    promise.catch(callback);
                    return promise;
                };
                return promise;
            };
            this.getStudentAttendanceDetails = function (model) {
                var deferred = $q.defer(),
                    promise = deferred.promise;
                $http.post(apiUrl + 'student/attendance/get-student-attendance-details/', model)
                .then(function (resp) {
                    //var student = new Student(resp.data);
                    deferred.resolve(resp.data);
                })
                .catch(function (error) {
                    deferred.reject(error);
                });
                promise.success = function (callback) {
                    promise.then(callback);
                    return promise;
                };
                promise.error = function (callback) {
                    promise.catch(callback);
                    return promise;
                };
                return promise;
            };

            this.getClassscheduleDetails = function (model) {
                var deferred = $q.defer(),
                    promise = deferred.promise;
                $http.post(apiUrl + 'student/attendance/get-class-schedule-details/', model)
                .then(function (resp) {
                   // var student = new Student(resp.data);
                    deferred.resolve(resp.data);
                })
                .catch(function (error) {
                    deferred.reject(error);
                });
                promise.success = function (callback) {
                    promise.then(callback);
                    return promise;
                };
                promise.error = function (callback) {
                    promise.catch(callback);
                    return promise;
                };
                return promise;
            };

        }]);
 });
/// <reference path="scripts/angular-click-outside/clickoutside.directive.js" />
/*global define,console,angular,require*/
define([
    'angularAMD',
    'angular-ui-router',
    'app/eruditeconfig',
    'xtForm',
    'angular-cookies',
    'app/Shared/Services/login-service',
    'app/Crm/user-config',
    //'app/Setup/setup-config',
    'toaster',
    'ui-select',
    'app/Shared/fzSubmit/Directives/fz-submit',
    'app/Shared/fzCancel/Directives/fz-cancel',
    'app/Shared/fzClose/Directives/fz-close',
    'app/Shared/Directives/loadingIndicator',
    'app/Shared/fzUiTrim/fz-UiTrim',
    'perfectScrollbarJQuery',
    'extensions',
    'app/Shared/Services/forgot-password-modal-service'
], function (angularAMD) {
    var dependencies = [
   // 'pscroll',
  //'eruditeApp.SharedModule',
  //'eruditeApp.SetupModule',
  'eruditeApp.UserModule',
  //'eruditeApp.PatientModule',
  'eruditeApp.Config',
  'ui.router',
  'eruditeApp.Shared.FormSubmitDirective',
  'eruditeApp.Shared.FormCancelDirective',
  'eruditeApp.Shared.ModelCloseDirective',
  'eruditeApp.Shared.UiTrimDirective',
  'eruditeApp.Shared.ForgotPasswordModalService',
  //'ngMessages',
 // 'ngEnter',
  'ui.select',
  //'ui.mask',

  'ngCookies',
  'xtForm',
  'eruditeApp.Shared.LoginService',
  'toaster',
  'loadingIndicator',
    ];

    var app = angular
 .module('eruditeApp', dependencies)
 .config([
  '$compileProvider',
  '$httpProvider',
  '$stateProvider',
  '$urlRouterProvider',
  'xtFormConfigProvider',
  '$provide',
  function ($compileProvider, $httpProvider, $stateProvider, $urlRouterProvider, xtFormConfigProvider, $provide) {
      //Enable following for production...
      //$compileProvider.debugInfoEnabled(false);

      $httpProvider.defaults.withCredentials = true;
      $urlRouterProvider.otherwise('/login');
      // xtForm form validation strategy.
      xtFormConfigProvider.addValidationStrategy('customStrategy', function (form, ngModel) {
          return ngModel.$invalid && form.$submitted;
      });
      xtFormConfigProvider.setDefaultValidationStrategy('customStrategy');
      $stateProvider
                      .state('login', angularAMD.route({
                          url: '/login',
                          title: 'Login',
                          templateUrl: '/app/Shared/Templates/login.html',
                          controllerUrl: 'app/Shared/Controllers/login-controller.js',
                          controller: 'loginController'
                      }))

                      .state('login.forgotpassword', {
                          url: '/forgotpassword',
                          title: 'Forgot Password',
                          onEnter: ['$state', '$$ForgotPasswordModalService',
                              function ($state, $$ForgotPasswordModalService) {
                                  $$ForgotPasswordModalService.open()
                                      .then(function (data) {
                                          $state.go('^', {}, {});
                                      }).catch(function (err) {
                                          $state.go('^', {}, {});
                                      });
                              }]
                      })

                      .state('setpassword', angularAMD.route({
                          url: '/set-password/{token:[0-9A-Za-z=]+\/?}',
                          title: 'Set Password email link',
                          templateUrl: 'app/Shared/Templates/setpassword.html',
                          controller: 'setpasswordController',
                          controllerUrl: 'app/Shared/Services/setpassword-service.js',
                      }))

                      .state('insufficientprivilege', angularAMD.route({
                          url: '/insufficient-privilege',
                          title: 'Insufficient Privilege',
                          templateUrl: 'app/Shared/Templates/insufficientprivilege.html'
                      }))

                      .state('app', angularAMD.route({
                          abstract: true,
                          data: {
                              requireLogin: true
                          },
                          url: '/',
                          templateUrl: '/app/Shared/Templates/app.html'
                      }));

      $httpProvider.interceptors.push(['$timeout', '$q', '$injector', '$rootScope', function ($timeout, $q, $injector, $rootScope) {
          var toaster, state;
          // this trick must be done so that we don't receiev
          // `Uncaught Error: [$injector:cdep] Circular dependency found`
          $timeout(function () {
              toaster = $injector.get('toaster');
              state = $injector.get('$state');
          });
          return {
              request: function (request) {
                  $rootScope.isLoading = true;
                  return request || $q.when(request);
              },
              response: function (response) {
                  $rootScope.isLoading = false;
                  return response || $q.when(response);
              },
              responseError: function (rejection) {
                  $rootScope.isLoading = false;
                  console.log(rejection.status);
                  switch (rejection.status) {
                      case 302:
                          toaster.error("Duplicate login");
                          state.go('login');
                          break;
                      case 401:
                          var UnAuthenticatedUser = rejection.headers()["UnAuthenticatedUser"];
                          if (angular.isDefined(UnAuthenticatedUser) && UnAuthenticatedUser === 'true') {
                              state.go('login');
                          }
                          else {
                              state.go("insufficientprivilege");
                          }
                          //header exist redirect to login else insuf prev
                          //  if()

                          //toaster.error("error 401");
                          break;
                      case 403:
                          //toaster.error("error 403");
                          state.go('login');
                          break;
                      case 400: break;
                      default:
                          toaster.error("Something went wrong. Please try again later.");
                          break;
                  }
                  if (rejection.status !== 0) {
                      return $q.reject(rejection);
                  }
                  var deferred = $q.defer();
                  // toaster.error("WebAPI is down, please contact Administrator");
                  deferred.reject(rejection);
                  return deferred.promise;
              }
          };
      }]);
      $provide.decorator('$exceptionHandler', ['$delegate', '$injector', function ($delegate, $injector) {
          return function (exception, cause) {
              var $toaster = $injector.get('toaster');
              $delegate(exception, cause);
              var appErrorMessage = "An Error Occurred";
              var errorData = { exception: exception, cause: cause };
              $toaster.error(appErrorMessage);
              console.log(exception.message, errorData);
          };
      }]);
  }
 ])

.run(['$rootScope', '$state', '$stateParams', '$cookies', '$$Login', '$templateCache', 'ERUDITE_CONFIG', 'toaster',
  function ($rootScope, $state, $stateParams, $cookies, $$Login, $templateCache, ERUDITE_CONFIG, toaster) {

      // It's very handy to add references to $state and $stateParams to the $rootScope
      // so that you can access them from any scope within your applications.For example,
      // <li ng-class="{ active: $state.includes('contacts.list') }"> will set the <li>
      // to active whenever 'contacts.list' or one of its decendents is active.
      $rootScope.$state = $state;
      $rootScope.$stateParams = $stateParams;


      // xtForm validation summary template, template can be modified in fuzeconfig.json
      var xtFormValidationSummaryTemplate = ERUDITE_CONFIG.xtForm.validationSummaryTemplate;
      $templateCache.put('xtForm/summary/validationSummary.html', xtFormValidationSummaryTemplate);

      // $stateChangeStart event of ui.router handled, for checking if login required, if required check if already logged in
      // otherwise redirect to the login state.
      $rootScope.$on('$stateChangeStart', function (event, toState, toParams) {
          if (toState.redirectTo) {
              event.preventDefault();
              return $state.go(toState.redirectTo, toParams);
          }


          var requireLogin = false;
          if (toState.data) {
              requireLogin = toState.data.requireLogin;
          }

          if (requireLogin) {
              var userLoggedIn = $cookies.get('userloggedin') == 'true';

              //State requires login

              if (!userLoggedIn) {
                  event.preventDefault();
                  //State change goto login state
                  return $state.go('login');
              }

              if (userLoggedIn && !angular.isUndefined($rootScope.User) && toState.privilegeId && !$$Login.CheckPrivileges(toState.privilegeId, 'VIEW')) {
                  event.preventDefault();
                  return $state.go('insufficientprivilege');
              }
              if (userLoggedIn && typeof $rootScope.User === 'undefined') {
                  event.preventDefault();
                  //userLoggedIn cookie is set, but context is not populated yet...

                  $$Login.GetUserContext()
                    .then(function () {
                        //userLoggedIn cookie is set, user context population completed
                        return $state.go(toState.name, toParams);
                    })
                    .catch(function () {
                        console.log("$rootScope.$on('$stateChangeStart'..., couldn't load user context...");
                        return $state.go('login');
                    });
              }
          }
      });

      var extensions = require('extensions');
      extensions();
  }
]);

    // Bootstrap Angular when DOM is ready
    angularAMD.bootstrap(app);

    return app;

});